# Flex： 一个在 Sui 上的 NFT 交易平台

注意：本文的中文版本比较相对英文版本 [README.md](./README.md) 要简略，更详细信息请参考英文版本。

## 需求

[TBD]

## 前置条件

[TBD]

## 开发前置条件

## 编码

### 编写 DDDML 模型文件

### 运行项目 dddappp 创建工具

### 实现业务逻辑

对于链上合约部分，工具为我们创建了大量的 Move 代码，凡是以注释 `// <autogenerated>` 开头的代码，我们不应该修改它们。

实现业务逻辑代码的工作，主要是在那些后缀为 `_logic.move` 的文件中进行。

## 测试应用

### 一些可能需要的准备工作

#### 准备 SUI coin 对象

查看当前账户中的 SUI Coin 对象：

```shell
sui client gas
```

如果你的账户只有一个 Sui Coin 对象，可以先给自己的账户转一些 SUI，以达到 split 这个 Sui Coin 对象的目的。
下面的测试中，我们除了需要使用一个 Sui Coin 对象来付 gas 费之外，还需要使用一个 Sui Coin 对象来添加流动性：

```shell
sui client pay-sui --input-coins 0x4715b65812e202a97f47f7dddf288776fabae989d1288c2e17c616c566abc294 --amounts 1000000000 \
--recipients 0xfc50aa2363f3b3c5d80631cae512ec51a8ba94080500a981f4ae1a2ce4d201c2 --gas-budget 30000000
```

#### Mint 一些 Movescription 代币

我们已经在 testnet 上部署了一个 movescription 测试合约，它的 package ID：`0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff`。

测试铭文 `MOVE` 的 `TickRecord` 的对象 ID：`0x34fccc1a953d02f3a7ddbd546e7982aff89c6989c8181d34e788bd855cb6ff64`。

注意使用 Sui CLI 测试时，先切换环境到 testnet：

```shell
sui client switch --env testnet
```

Mint 一些 `MOVE` 测试铭文（每次 mint 请间隔一分钟），注意，第三个参数，也就是下面示例的 `0x44e677e7fbfebef80d484eca63e350a1e8d9d5da4ab5a1e757d7e22a2d0a7b2c` 
应该改为你的一个 SUI Coin 对象的 Id。

```shell
sui client call --package 0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff --module movescription --function mint --args 0x34fccc1a953d02f3a7ddbd546e7982aff89c6989c8181d34e788bd855cb6ff64 \"MOVE\" 0x44e677e7fbfebef80d484eca63e350a1e8d9d5da4ab5a1e757d7e22a2d0a7b2c \"0x6\" --gas-budget 19000000
```

Split 一个铭文：

```shell
sui client call --package 0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff --module movescription --function split --args  0xfc8debdede996da1901ec9090ac8d6cda8478705f6c8bad64056b540ff6b4f8c '"1000"' --gas-budget 19000000
```

```shell
sui client call --package 0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c --module equipment --function mint --args '1' --gas-budget 11000000
sui client call --package 0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c --module equipment --function mint --args '2' --gas-budget 11000000
sui client call --package 0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c --module equipment --function mint --args '3' --gas-budget 11000000
```

#### Mint 一些测试 NFTs

为了测试，我们可以部署这个合约： `./sui-contracts/example_tokens/sources/equipment.move`。

在 testnet 我们已经把这个合约部署在地址（Package ID）： `0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c`。

然后，我们可以这样 mint 一些 NFTs 用于测试：

```shell
sui client call --package 0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c --module equipment --function mint --args '1' --gas-budget 11000000
sui client call --package 0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c --module equipment --function mint --args '2' --gas-budget 11000000
sui client call --package 0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c --module equipment --function mint --args '3' --gas-budget 11000000
```

（在 testnet 上，我们还在另外一个地址部署了该合约：`0x507d2aacb7425085612e0d56131a57362729779bf3510c286b98568479314920`。
Transaction Digest: `44kiFkx9im8G4RNs5ZaBpB1KN9LL7tRLHZXWRZ8FvKGm`。
）

### 部署合约

执行以下命令部署合约：

```shell
sui client publish --gas-budget 1000000000 --skip-fetch-latest-git-deps
```

如果命令执行成功，在终端中会输出这次发布的交易摘要。比如：

```*shell
*----- Transaction Digest ----
267z86Ge4Phdow8AH424uw9WPqBhrGSUbjMsuA6cpEzp
----- Transaction Data ----
#...
```

记录下这个交易摘要，比如 `267z86Ge4Phdow8AH424uw9WPqBhrGSUbjMsuA6cpEzp`。
在设置链下服务的时候，我们需要用到它。


### 初始化流动性

[TBD]

### 添加流动性

[TBD]

### 移除流动性

[TBD]

### 兑换

[TBD]

### 关于更新池子的 NFT 价格设置

#### Linear 价格曲线设置

当价格曲线类型为 Linear 时，前端允许用户输入：

* 当前价格（`current_exchange_rate`）。表示最小单位的 NFT 兑换 FT（Coin）的价格。
* 价格增量的绝对值（`absolute_price_delta`）。价格增量比例记为 `price_delta` = `absolute_price_delta` / `current_exchange_rate`。

根据这两个值，我们可以这样计算出新的价格曲线参数：

* `exchange_rate_numerator` = `current_exchange_rate` 的分子部分。
* `exchange_rate_denominator` = `current_exchange_rate` 的分母部分。比如，如果 `current_exchange_rate` 为 1.005，那么 `exchange_rate_numerator` 可以为 1005，`exchange_rate_denominator` 可以为 1000。
* `start_exchange_rate_numerator` = `exchange_rate_numerator`.
* `price_delta_numerator` = `price_delta` 的分子部分。
* `price_delta_denominator` = `price_delta` 的分母部分。
* `price_delta_x_amount`，一般不变。

#### 指数价格曲线设置

当价格曲线类型为 Exponential 时，前端允许用户输入：

* 当前价格（`current_exchange_rate`）。表示最小单位的 NFT 兑换 FT（Coin）的价格。
* 价格增量的比例（`price_delta`）。一般使用百分比表示，比如 `0.5%`。

根据这两个值，我们可以这样计算出新的价格曲线参数：

* `exchange_rate_numerator` = `current_exchange_rate` 的分子部分。
* `exchange_rate_denominator` = `current_exchange_rate` 的分母部分。
* `start_exchange_rate_numerator`，可以不变。因为指数价格计算的时候，不会用到这个值。
* `price_delta_numerator` = `price_delta` 的分子部分。
* `price_delta_denominator` = `price_delta` 的分母部分。比如，如果 `price_delta` 为 0.5%，那么 `price_delta_numerator` 可以为 5，`price_delta_denominator` 可以为 1000。
* `price_delta_x_amount`，一般不变。


### 测试链下服务

#### 配置链下服务

[TBD]

#### 创建链下服务的数据库

[TBD]

#### 启动链下服务

[TBD]

#### 获取 NFT collection 的列表

可以使用低代码工具默认即从模型生成的接口：

```shell
curl -X GET "http://localhost:1023/api/NftCollections" -H "accept: application/json"
```

注意：CoinType 属于池子的信息，不属于 NFT collection 的信息。因为一个 NFT 协议（项目）不会关心我们的池子使用什么 CoinType 和它们的 NFT 组成流动性。

返回的数据示例：

```json
[
  {
    "collectionType": "0x507d2aacb7425085612e0d56131a57362729779bf3510c286b98568479314920::equipment::Equipment",
    "name": "Test NFT 2",
    "imageUrl": "https://arweave.net/WA1r_yylVVWTBIV8e18xeWwlCTZvdQ7XQ5CKVvZ74EA",
    "diPackageId": "0x9418aace582389a2f0108b9b7092bfcc26658e09eff1eb1c2564d4a1f4b278e2",
    "diBuyPoolServiceModuleName": "test_equipment_buy_pool_service",
    "diSellPoolServiceModuleName": "test_equipment_sell_pool_service",
    "diTradePoolServiceModuleName": "test_equipment_trade_pool_service",
    "nftServiceImplPackageId": "0x091e6daa7d6e000290fbdae96cd12b44619e98b956af9838921a7942e17ab5e2",
    "nftServiceImplModuleName": "test_equipment_service_impl",
    "basicUnitAmount": 1,
    "amountFieldName": "amount",
    "subtypeFieldName": "type",
    "subtypes": [
      {
        "subtypeValue": "1",
        "name": "Brick",
        "imageUrl": "https://arweave.net/6AXZZCbeJLoOiexVs4TbWYcBvAtHsP8j0b0TZCLovs0",
        "subtypeAmount": 1
      },
      {
        "subtypeValue": "2",
        "name": "Shield",
        "imageUrl": "https://arweave.net/8CXgwIU2n7nVj9Bw5SAz5Kj_16OPUaNnOuYDEqCV5eQ",
        "subtypeAmount": 3
      },
      {
        "subtypeValue": "3",
        "name": "Sword",
        "imageUrl": "https://arweave.net/ItEzNg2lSS1Ne5ir5Cfbcyvi2HNsx5e6Et4LvzQx2rA",
        "subtypeAmount": 5
      }
    ]
  },
  //...
]
```

解释：

* `amountFieldName`: 表示 NFT 的价值的字段的名称。
* `subtypeFieldName`: 如果 NFT 有子类型，表示“子类型”的字段的名称。
* `subtypes`: 如果 NFT 有子类型，这个数组表示子类型的信息。
    * `subtypeValue`: 子类型的值。
    * `name`: 子类型的名称。
    * `imageUrl`: 子类型的图片 URL，可能为空。
    * `subtypeAmount`: 子类型的价值，如果子类型的实例有统一的价值，该字段会被设置。


#### 获取 一个 NFT collection 的信息

```shell
curl -X GET "http://localhost:1023/api/NftCollections/0x507d2aacb7425085612e0d56131a57362729779bf3510c286b98568479314920::equipment::Equipment" -H "accept: application/json"
```

#### 获取多个池子中的 NFT 资产

需要注意 NFT/FT 池子支持的 CoinType（FT type）不只是 SUI coin，所以这里需要传入 coinType 参数（如果目前只支持 SUI coin，那么这里可以先硬编码为 SUI coin）。

```shell
curl -X GET "http://localhost:1023/api/nftPools/assets?nftType=0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c%3A%3Aequipment%3A%3AEquipment&coinType=0x2%3A%3Asui%3A%3ASUI" -H "accept: application/json"
```

提示：路径 `/api/nftPools/` 下的接口是“定制开发”的，不是低代码工具生成的。

如果只想要获得“可购买的”（即在 trade pool 或者 sell pool 中的）资产，可以加上查询参数 `buyable=true`：

```shell
curl -X GET "http://localhost:1023/api/nftPools/assets?nftType=0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c%3A%3Aequipment%3A%3AEquipment&coinType=0x2%3A%3Asui%3A%3ASUI&buyable=true" -H "accept: application/json"
# PoolType:
#    const TRADE_POOL: u8 = 0;
#    const SELL_POOL: u8 = 1;
#    const BUY_POOL: u8 = 2;
# TradePool and SellPool are buyable.
# TradePool and BuyPool are sellable.
```

#### 获取某个地址拥有的 NFT 资产

这个方法实际上是 Sui JSON-RPC `suix_getOwnedObjects` 以及 `sui_getObject` 方法的封装。获取的的链上某个地址（而不是池子）拥有的 NFT 资产。

```shell
curl -X GET "http://localhost:1023/api/nftPools/ownedAssets?nftType=0x507d2aacb7425085612e0d56131a57362729779bf3510c286b98568479314920%3A%3Aequipment%3A%3AEquipment&address=0xfc50aa2363f3b3c5d80631cae512ec51a8ba94080500a981f4ae1a2ce4d201c2" -H "accept: application/json"
```

#### 获取某个地址拥有的池子的列表

这个方法先调用 Sui JSON-RPC `suix_getOwnedObjects` 方法获取某个地址拥有的 Liquidity token 对象，
然后查询链下数据库获取这些 Liquidity token 对象对应的池子,
然后调用 Sui JSON-RPC `sui_getObject` 方法获取池子的详细信息。

```shell
curl -X GET "http://localhost:1023/api/nftPools/ownedPools?address=0xfc50aa2363f3b3c5d80631cae512ec51a8ba94080500a981f4ae1a2ce4d201c2" -H "accept: application/json"
```

一般而言，一个地址拥有的池子数量不会太多。如果需要过滤不同类型的池子，客户端可以获取全部类型的池子后自行过滤。


#### 获取 Pools 的列表

获取池子的信息可以使用低代码工具默认生成的接口：

```shell
curl -X GET "http://localhost:1023/api/TradePools" -H "accept: application/json"
```

> **注意**
>
> 你可能已经注意到这个接口返回的“池子”的数据结构，和“获取某个地址拥有的池子的列表”所返回的数据结构有差异。
这是因为这个接口是直接查询链下数据库，然后把查询结果返回给客户端，数据结构更接近链下数据库的数据结构；
而“获取某个地址拥有的池子的列表”是将调用 Sui JSON-RPC 接口获取的池子对象的信息直接返回给客户端。这两者的数据结构存在差异。
（调整成一致的数据结构需要更多的工作，先这样吧。）


可以根据池子的类型过滤池子的列表：

```shell
curl -X GET "http://localhost:1023/api/TradePools?poolType=2" -H "accept: application/json"
```

过滤出 trade pool 和 buy pool 的列表（可以向这两种池子卖出 NFT），重复的查询参数表示 OR 关系：

```shell
curl -X GET "http://localhost:1023/api/TradePools?poolType=0&poolType=2" -H "accept: application/json"
```

根据池子的 Token pair 的类型过滤池子的列表（当然其他属性也可以作为过滤条件）：

```shell
curl -X GET "http://localhost:1023/api/TradePools?x_TokenType=0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c::equipment::Equipment&y_TokenType=0x2::sui::SUI" -H "accept: application/json"
```

#### 获取 NFT 的购买价格

当需要购买 NFT 时，可以调用这个接口获取从 sell pool 或 trade pool 购买 NFT 的价格，示例：

```shell
curl -X GET "http://localhost:1023/api/nftPools/buySpotPrices?nftType=0x507d2aacb7425085612e0d56131a57362729779bf3510c286b98568479314920%3A%3Aequipment%3A%3AEquipment&coinType=0x2%3A%3Asui%3A%3ASUI&nftAmountLimit=10" -H "accept: application/json"
```

这里的查询参数 `nftAmountLimit` 表示需要计算的（欲购买的） NFT 的总价值。

返回的数据示例：

```json
[
  {
    "poolObjectId": "0x2cf28fa6e72b3f63bc4414857fb8dca6908443a7339c8631b6da8497344d87f0",
    "nftType": "0x507d2aacb7425085612e0d56131a57362729779bf3510c286b98568479314920::equipment::Equipment",
    "coinType": "0x2::sui::SUI",
    "nftBasicUnitAmount": "1",
    //...
    "spotPrices": [
      {
        "coinAmount": 1008999991,
        "nftAmount": 1
      },
      {
        "coinAmount": 1009999990,
        "nftAmount": 1
      },
      {
        "coinAmount": 1010999989,
        "nftAmount": 1
      },
      //...
  },
  //...
]
```

解释：

* `nftBasicUnitAmount`：每购买这个“基本单位价值”的 NFT，池子的点价格（spot price）就会更新一次。
* `spotPrices`：这个数组可以理解为向该池子**依次**购买若干个 NFT 时，每个 NFT 所需要支付的 Coin 的金额。
    也就是说，它的元素其实表示的是购买某个 NFT 时的“点价格”。
    * `nftAmount`：目前总是等于 `nftBasicUnitAmount`。未来接口支持计算购买特定子类型的 NFT（它们的价值不一定等于“基本单位价值”）的价格时，这个值可能会变化。
    * `coinAmount`：购买价值为 `nftAmount` 的 NFT需支付的 Coin 的金额。

比如，我们测试的 NFT 项目，`nftBasicUnitAmount` 为 1。
各个 NFT 子类型的价值是“基本单位价值”的倍数，其中`Block` 的价值是 1，`Shield` 的价值是 3，`Sword` 的价值是 5。
当我们需要一次性混合购买多个 NFT（可能既有 `Block` 又有 `Shield`，还有 `Sword`）时，
前端可以按照“基本单位价值”来获取各个池子的多个点价格，计算出最佳购买方案。


#### 获取 NFT 的出售价格

当需要出售 NFT 时，可以调用这个接口获取向 buy pool 或 trade pool 销售 NFT 的价格，示例：

```shell
curl -X GET "http://localhost:1023/api/nftPools/sellSpotPrices?nftType=0x507d2aacb7425085612e0d56131a57362729779bf3510c286b98568479314920%3A%3Aequipment%3A%3AEquipment&coinType=0x2%3A%3Asui%3A%3ASUI&nftAmountLimit=20" -H "accept: application/json"
```

参考“获取 NFT 的购买价格”接口。


### 关于链下服务 API

我们的链下服务将链上的对象状态拉取到链下的 SQL 数据库，以提供查询功能。这样一个链下服务有时候也被称为 indexer。

我们当然可以先使用 Sui 官方提供的 API 服务，见：https://docs.sui.io/references/sui-api 
但是，有些应用特定的查询需求，Sui 官方的 API 服务可能并不能满足，所以，很多应有都有必要自己搭建或者使用第三方提供的增强的查询或检索服务。 

默认情况下，我们生成的链下服务提供了一些开箱即用的 API。你可以阅读 DDDML 模型文件，然后参考下面的示例来推断有哪些 API 可以使用。

比如，在我们这个项目中，你可以这样获取代币对列表：

```text
http://localhost:1023/api/TokenPairs
```

这里你甚至可以使用查询条件：

```text
http://localhost:1023/api/TokenPairs?totalLiquidity=gt(100)&x_Reserve.tick=MOVE
```

获取某个代币对的信息：

```text
http://localhost:1023/api/TokenPairs/0xe5bb0aa9fcd7ce57973bd3289f5b1ab0f946c47f3273641c3527a5d26775a5ac
```

获取流动性 Token 的列表：

```text
http://localhost:1023/api/LiquidityTokens
```

获取某个流动性 Token 的信息：

```text
http://localhost:1023/api/LiquidityTokens/0x1c934038fbb356446add349062e9fad959820c5998c80f6f363969d07288cb16
```

#### 获取实体列表的查询参数

可以在获取列表的请求 URL 中支持的查询参数，包括：

* sort：用于排序的属性名称。多个属性名称可以英文逗号分隔。属性名称前面有“-”则表示倒序排列。
    查询参数 `sort` 还可以多次出现，像这样：`sort=fisrtName&sort=lastName,desc`。
* fields：需要返回的字段（属性）名称。多个名称可以逗号分隔。
* filter：返回结果的过滤器，后文会进一步解释。
* firstResult：返回结果中第一条记录的序号，从 0 开始计算。
* maxResults：返回结果的最大记录数量。

#### 获取实体列表的 Page 封包

虽然我个人并不喜欢“封包”，但是因为有些开发人员强烈要求，我们还是支持发送 GET 请求到这个 URL 以获取的列表的 Page（分页）封包：

```url
{BASE_URL}/{Entities}/_page?page={page}
```

支持的分页相关的查询参数：

* page：获取第几页（从 0 开始）。
* size：Page size。

比如：

```text
http://localhost:1023/api/TokenPairs/_page?page=0&size=10
```

#### 还需要更多的查询功能？

由于链下服务已经将链上的对象状态拉取到链下的 SQL 数据库，所以，我们可以使用任意 SQL 查询语句来查询链下服务的数据库。
将这些 SQL 查询语句封装成 API，是非常容易的事情。如果你有这样的需求，修改源代码，添加你需要的 API 即可。


