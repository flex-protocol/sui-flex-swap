// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module sui_swap_example::token_pair_aggregate {
    use sui::balance::Balance;
    use sui::tx_context;
    use sui_swap_example::exchange::Exchange;
    use sui_swap_example::liquidity_token::LiquidityToken;
    use sui_swap_example::token_pair;
    use sui_swap_example::token_pair_deposit_y_reserve_logic;
    use sui_swap_example::token_pair_initialize_token_pair_logic;
    use sui_swap_example::token_pair_swap_x_logic;
    use sui_swap_example::token_pair_update_exchange_rate_logic;
    use sui_swap_example::token_pair_withdraw_x_reserve_logic;
    use sui_swap_example::token_pair_withdraw_y_reserve_logic;

    friend sui_swap_example::token_pair_service;

    #[allow(unused_mut_parameter)]
    public fun initialize_token_pair<X, Y>(
        exchange: &mut Exchange,
        y_amount: Balance<Y>,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        ctx: &mut tx_context::TxContext,
    ) {
        let token_pair_initialized = token_pair_initialize_token_pair_logic::verify<X, Y>(
            exchange,
            &y_amount,
            exchange_rate_numerator,
            exchange_rate_denominator,
            ctx,
        );
        let token_pair = token_pair_initialize_token_pair_logic::mutate<X, Y>(
            &token_pair_initialized,
            y_amount,
            exchange,
            ctx,
        );
        token_pair::set_token_pair_initialized_id(&mut token_pair_initialized, token_pair::id(&token_pair));
        token_pair::share_object(token_pair);
        token_pair::emit_token_pair_initialized(token_pair_initialized);
    }

    #[allow(unused_mut_parameter)]
    public entry fun update_exchange_rate<X, Y>(
        token_pair: &mut token_pair::TokenPair<X, Y>,
        liquidity_token: &LiquidityToken<X, Y>,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        ctx: &mut tx_context::TxContext,
    ) {
        token_pair::assert_schema_version(token_pair);
        let exchange_rate_updated = token_pair_update_exchange_rate_logic::verify<X, Y>(
            liquidity_token,
            exchange_rate_numerator,
            exchange_rate_denominator,
            token_pair,
            ctx,
        );
        token_pair_update_exchange_rate_logic::mutate<X, Y>(
            &exchange_rate_updated,
            token_pair,
            ctx,
        );
        token_pair::update_object_version(token_pair);
        token_pair::emit_exchange_rate_updated(exchange_rate_updated);
    }

    #[allow(unused_mut_parameter)]
    public fun deposit_y_reserve<X, Y>(
        token_pair: &mut token_pair::TokenPair<X, Y>,
        y_amount: Balance<Y>,
        ctx: &mut tx_context::TxContext,
    ) {
        token_pair::assert_schema_version(token_pair);
        let y_reserve_deposited = token_pair_deposit_y_reserve_logic::verify<X, Y>(
            &y_amount,
            token_pair,
            ctx,
        );
        token_pair_deposit_y_reserve_logic::mutate<X, Y>(
            &y_reserve_deposited,
            y_amount,
            token_pair,
            ctx,
        );
        token_pair::update_object_version(token_pair);
        token_pair::emit_y_reserve_deposited(y_reserve_deposited);
    }

    #[allow(unused_mut_parameter)]
    public fun withdraw_x_reserve<X, Y>(
        token_pair: &mut token_pair::TokenPair<X, Y>,
        liquidity_token: &LiquidityToken<X, Y>,
        x_amount: u64,
        ctx: &mut tx_context::TxContext,
    ): Balance<X> {
        token_pair::assert_schema_version(token_pair);
        let x_reserve_withdrawn = token_pair_withdraw_x_reserve_logic::verify<X, Y>(
            liquidity_token,
            x_amount,
            token_pair,
            ctx,
        );
        let withdraw_x_reserve_return = token_pair_withdraw_x_reserve_logic::mutate<X, Y>(
            &x_reserve_withdrawn,
            token_pair,
            ctx,
        );
        token_pair::update_object_version(token_pair);
        token_pair::emit_x_reserve_withdrawn(x_reserve_withdrawn);
        withdraw_x_reserve_return
    }

    #[allow(unused_mut_parameter)]
    public fun withdraw_y_reserve<X, Y>(
        token_pair: &mut token_pair::TokenPair<X, Y>,
        liquidity_token: &LiquidityToken<X, Y>,
        y_amount: u64,
        ctx: &mut tx_context::TxContext,
    ): Balance<Y> {
        token_pair::assert_schema_version(token_pair);
        let y_reserve_withdrawn = token_pair_withdraw_y_reserve_logic::verify<X, Y>(
            liquidity_token,
            y_amount,
            token_pair,
            ctx,
        );
        let withdraw_y_reserve_return = token_pair_withdraw_y_reserve_logic::mutate<X, Y>(
            &y_reserve_withdrawn,
            token_pair,
            ctx,
        );
        token_pair::update_object_version(token_pair);
        token_pair::emit_y_reserve_withdrawn(y_reserve_withdrawn);
        withdraw_y_reserve_return
    }

    #[allow(unused_mut_parameter)]
    public fun swap_x<X, Y>(
        token_pair: &mut token_pair::TokenPair<X, Y>,
        x_amount: Balance<X>,
        ctx: &mut tx_context::TxContext,
    ): Balance<Y> {
        token_pair::assert_schema_version(token_pair);
        let x_swapped_for_y = token_pair_swap_x_logic::verify<X, Y>(
            &x_amount,
            token_pair,
            ctx,
        );
        let swap_x_return = token_pair_swap_x_logic::mutate<X, Y>(
            &x_swapped_for_y,
            x_amount,
            token_pair,
            ctx,
        );
        token_pair::update_object_version(token_pair);
        token_pair::emit_x_swapped_for_y(x_swapped_for_y);
        swap_x_return
    }

}
