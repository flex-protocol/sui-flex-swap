// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module sui_swap_example::token_pair {
    use std::option;
    use std::string::String;
    use sui::balance::Balance;
    use sui::event;
    use sui::object::{Self, ID, UID};
    use sui::transfer;
    use sui::tx_context::TxContext;

    struct TOKEN_PAIR has drop {}

    friend sui_swap_example::token_pair_initialize_token_pair_logic;
    friend sui_swap_example::token_pair_update_exchange_rate_logic;
    friend sui_swap_example::token_pair_deposit_y_reserve_logic;
    friend sui_swap_example::token_pair_withdraw_x_reserve_logic;
    friend sui_swap_example::token_pair_withdraw_y_reserve_logic;
    friend sui_swap_example::token_pair_swap_x_logic;
    friend sui_swap_example::token_pair_aggregate;

    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const EEmptyObjectID: u64 = 107;

    /// Not the right admin for the object
    const ENotAdmin: u64 = 0;
    /// Migration is not an upgrade
    const ENotUpgrade: u64 = 1;
    /// Calling functions from the wrong package version
    const EWrongSchemaVersion: u64 = 2;

    const SCHEMA_VERSION: u64 = 0;

    struct AdminCap has key {
        id: UID,
    }


    fun init(otw: TOKEN_PAIR, ctx: &mut TxContext) {
        sui::package::claim_and_keep(otw, ctx)
    }

    public fun assert_schema_version<X, Y>(token_pair: &TokenPair<X, Y>) {
        assert!(token_pair.schema_version == SCHEMA_VERSION, EWrongSchemaVersion);
    }

    struct TokenPair<phantom X, phantom Y> has key {
        id: UID,
        version: u64,
        schema_version: u64,
        admin_cap: ID,
        x_reserve: Balance<X>,
        y_reserve: Balance<Y>,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        liquidity_token_id: ID,
    }

    public fun id<X, Y>(token_pair: &TokenPair<X, Y>): object::ID {
        object::uid_to_inner(&token_pair.id)
    }

    public fun version<X, Y>(token_pair: &TokenPair<X, Y>): u64 {
        token_pair.version
    }

    public fun borrow_x_reserve<X, Y>(token_pair: &TokenPair<X, Y>): &Balance<X> {
        &token_pair.x_reserve
    }

    public(friend) fun borrow_mut_x_reserve<X, Y>(token_pair: &mut TokenPair<X, Y>): &mut Balance<X> {
        &mut token_pair.x_reserve
    }

    public fun borrow_y_reserve<X, Y>(token_pair: &TokenPair<X, Y>): &Balance<Y> {
        &token_pair.y_reserve
    }

    public(friend) fun borrow_mut_y_reserve<X, Y>(token_pair: &mut TokenPair<X, Y>): &mut Balance<Y> {
        &mut token_pair.y_reserve
    }

    public fun exchange_rate_numerator<X, Y>(token_pair: &TokenPair<X, Y>): u64 {
        token_pair.exchange_rate_numerator
    }

    public(friend) fun set_exchange_rate_numerator<X, Y>(token_pair: &mut TokenPair<X, Y>, exchange_rate_numerator: u64) {
        token_pair.exchange_rate_numerator = exchange_rate_numerator;
    }

    public fun exchange_rate_denominator<X, Y>(token_pair: &TokenPair<X, Y>): u64 {
        token_pair.exchange_rate_denominator
    }

    public(friend) fun set_exchange_rate_denominator<X, Y>(token_pair: &mut TokenPair<X, Y>, exchange_rate_denominator: u64) {
        token_pair.exchange_rate_denominator = exchange_rate_denominator;
    }

    public fun liquidity_token_id<X, Y>(token_pair: &TokenPair<X, Y>): ID {
        token_pair.liquidity_token_id
    }

    public(friend) fun set_liquidity_token_id<X, Y>(token_pair: &mut TokenPair<X, Y>, liquidity_token_id: ID) {
        token_pair.liquidity_token_id = liquidity_token_id;
    }

    public fun admin_cap<X, Y>(token_pair: &TokenPair<X, Y>): ID {
        token_pair.admin_cap
    }

    public(friend) fun new_token_pair<X, Y>(
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        liquidity_token_id: ID,
        ctx: &mut TxContext,
    ): TokenPair<X, Y> {
        let admin_cap = AdminCap {
            id: object::new(ctx),
        };
        let admin_cap_id = object::id(&admin_cap);
        transfer::transfer(admin_cap, sui::tx_context::sender(ctx));
        TokenPair {
            id: object::new(ctx),
            version: 0,
            schema_version: SCHEMA_VERSION,
            admin_cap: admin_cap_id,
            x_reserve: sui::balance::zero(),
            y_reserve: sui::balance::zero(),
            exchange_rate_numerator,
            exchange_rate_denominator,
            liquidity_token_id,
        }
    }

    entry fun migrate<X, Y>(token_pair: &mut TokenPair<X, Y>, a: &AdminCap) {
        assert!(token_pair.admin_cap == object::id(a), ENotAdmin);
        assert!(token_pair.schema_version < SCHEMA_VERSION, ENotUpgrade);
        token_pair.schema_version = SCHEMA_VERSION;
    }

    struct TokenPairInitialized has copy, drop {
        id: option::Option<object::ID>,
        exchange_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
        liquidity_token_id: ID,
    }

    public fun token_pair_initialized_id(token_pair_initialized: &TokenPairInitialized): option::Option<object::ID> {
        token_pair_initialized.id
    }

    public(friend) fun set_token_pair_initialized_id(token_pair_initialized: &mut TokenPairInitialized, id: object::ID) {
        token_pair_initialized.id = option::some(id);
    }

    public fun token_pair_initialized_exchange_id(token_pair_initialized: &TokenPairInitialized): ID {
        token_pair_initialized.exchange_id
    }

    public fun token_pair_initialized_exchange_rate_numerator(token_pair_initialized: &TokenPairInitialized): u64 {
        token_pair_initialized.exchange_rate_numerator
    }

    public fun token_pair_initialized_exchange_rate_denominator(token_pair_initialized: &TokenPairInitialized): u64 {
        token_pair_initialized.exchange_rate_denominator
    }

    public fun token_pair_initialized_provider(token_pair_initialized: &TokenPairInitialized): address {
        token_pair_initialized.provider
    }

    public fun token_pair_initialized_x_token_type(token_pair_initialized: &TokenPairInitialized): String {
        token_pair_initialized.x_token_type
    }

    public fun token_pair_initialized_y_token_type(token_pair_initialized: &TokenPairInitialized): String {
        token_pair_initialized.y_token_type
    }

    public fun token_pair_initialized_x_amount(token_pair_initialized: &TokenPairInitialized): u64 {
        token_pair_initialized.x_amount
    }

    public fun token_pair_initialized_y_amount(token_pair_initialized: &TokenPairInitialized): u64 {
        token_pair_initialized.y_amount
    }

    public fun token_pair_initialized_liquidity_token_id(token_pair_initialized: &TokenPairInitialized): ID {
        token_pair_initialized.liquidity_token_id
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_token_pair_initialized<X, Y>(
        exchange_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
        liquidity_token_id: ID,
    ): TokenPairInitialized {
        TokenPairInitialized {
            id: option::none(),
            exchange_id,
            exchange_rate_numerator,
            exchange_rate_denominator,
            provider,
            x_token_type,
            y_token_type,
            x_amount,
            y_amount,
            liquidity_token_id,
        }
    }

    struct ExchangeRateUpdated has copy, drop {
        id: object::ID,
        version: u64,
        liquidity_token_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
    }

    public fun exchange_rate_updated_id(exchange_rate_updated: &ExchangeRateUpdated): object::ID {
        exchange_rate_updated.id
    }

    public fun exchange_rate_updated_liquidity_token_id(exchange_rate_updated: &ExchangeRateUpdated): ID {
        exchange_rate_updated.liquidity_token_id
    }

    public fun exchange_rate_updated_exchange_rate_numerator(exchange_rate_updated: &ExchangeRateUpdated): u64 {
        exchange_rate_updated.exchange_rate_numerator
    }

    public fun exchange_rate_updated_exchange_rate_denominator(exchange_rate_updated: &ExchangeRateUpdated): u64 {
        exchange_rate_updated.exchange_rate_denominator
    }

    public fun exchange_rate_updated_provider(exchange_rate_updated: &ExchangeRateUpdated): address {
        exchange_rate_updated.provider
    }

    public fun exchange_rate_updated_x_token_type(exchange_rate_updated: &ExchangeRateUpdated): String {
        exchange_rate_updated.x_token_type
    }

    public fun exchange_rate_updated_y_token_type(exchange_rate_updated: &ExchangeRateUpdated): String {
        exchange_rate_updated.y_token_type
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_exchange_rate_updated<X, Y>(
        token_pair: &TokenPair<X, Y>,
        liquidity_token_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
    ): ExchangeRateUpdated {
        ExchangeRateUpdated {
            id: id(token_pair),
            version: version(token_pair),
            liquidity_token_id,
            exchange_rate_numerator,
            exchange_rate_denominator,
            provider,
            x_token_type,
            y_token_type,
        }
    }

    struct YReserveDeposited has copy, drop {
        id: object::ID,
        version: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        y_amount: u64,
    }

    public fun y_reserve_deposited_id(y_reserve_deposited: &YReserveDeposited): object::ID {
        y_reserve_deposited.id
    }

    public fun y_reserve_deposited_provider(y_reserve_deposited: &YReserveDeposited): address {
        y_reserve_deposited.provider
    }

    public fun y_reserve_deposited_x_token_type(y_reserve_deposited: &YReserveDeposited): String {
        y_reserve_deposited.x_token_type
    }

    public fun y_reserve_deposited_y_token_type(y_reserve_deposited: &YReserveDeposited): String {
        y_reserve_deposited.y_token_type
    }

    public fun y_reserve_deposited_y_amount(y_reserve_deposited: &YReserveDeposited): u64 {
        y_reserve_deposited.y_amount
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_y_reserve_deposited<X, Y>(
        token_pair: &TokenPair<X, Y>,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        y_amount: u64,
    ): YReserveDeposited {
        YReserveDeposited {
            id: id(token_pair),
            version: version(token_pair),
            provider,
            x_token_type,
            y_token_type,
            y_amount,
        }
    }

    struct XReserveWithdrawn has copy, drop {
        id: object::ID,
        version: u64,
        liquidity_token_id: ID,
        x_amount: u64,
        x_token_type: String,
        y_token_type: String,
    }

    public fun x_reserve_withdrawn_id(x_reserve_withdrawn: &XReserveWithdrawn): object::ID {
        x_reserve_withdrawn.id
    }

    public fun x_reserve_withdrawn_liquidity_token_id(x_reserve_withdrawn: &XReserveWithdrawn): ID {
        x_reserve_withdrawn.liquidity_token_id
    }

    public fun x_reserve_withdrawn_x_amount(x_reserve_withdrawn: &XReserveWithdrawn): u64 {
        x_reserve_withdrawn.x_amount
    }

    public fun x_reserve_withdrawn_x_token_type(x_reserve_withdrawn: &XReserveWithdrawn): String {
        x_reserve_withdrawn.x_token_type
    }

    public fun x_reserve_withdrawn_y_token_type(x_reserve_withdrawn: &XReserveWithdrawn): String {
        x_reserve_withdrawn.y_token_type
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_x_reserve_withdrawn<X, Y>(
        token_pair: &TokenPair<X, Y>,
        liquidity_token_id: ID,
        x_amount: u64,
        x_token_type: String,
        y_token_type: String,
    ): XReserveWithdrawn {
        XReserveWithdrawn {
            id: id(token_pair),
            version: version(token_pair),
            liquidity_token_id,
            x_amount,
            x_token_type,
            y_token_type,
        }
    }

    struct YReserveWithdrawn has copy, drop {
        id: object::ID,
        version: u64,
        liquidity_token_id: ID,
        y_amount: u64,
        x_token_type: String,
        y_token_type: String,
    }

    public fun y_reserve_withdrawn_id(y_reserve_withdrawn: &YReserveWithdrawn): object::ID {
        y_reserve_withdrawn.id
    }

    public fun y_reserve_withdrawn_liquidity_token_id(y_reserve_withdrawn: &YReserveWithdrawn): ID {
        y_reserve_withdrawn.liquidity_token_id
    }

    public fun y_reserve_withdrawn_y_amount(y_reserve_withdrawn: &YReserveWithdrawn): u64 {
        y_reserve_withdrawn.y_amount
    }

    public fun y_reserve_withdrawn_x_token_type(y_reserve_withdrawn: &YReserveWithdrawn): String {
        y_reserve_withdrawn.x_token_type
    }

    public fun y_reserve_withdrawn_y_token_type(y_reserve_withdrawn: &YReserveWithdrawn): String {
        y_reserve_withdrawn.y_token_type
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_y_reserve_withdrawn<X, Y>(
        token_pair: &TokenPair<X, Y>,
        liquidity_token_id: ID,
        y_amount: u64,
        x_token_type: String,
        y_token_type: String,
    ): YReserveWithdrawn {
        YReserveWithdrawn {
            id: id(token_pair),
            version: version(token_pair),
            liquidity_token_id,
            y_amount,
            x_token_type,
            y_token_type,
        }
    }

    struct XSwappedForY has copy, drop {
        id: object::ID,
        version: u64,
        sender: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
    }

    public fun x_swapped_for_y_id(x_swapped_for_y: &XSwappedForY): object::ID {
        x_swapped_for_y.id
    }

    public fun x_swapped_for_y_sender(x_swapped_for_y: &XSwappedForY): address {
        x_swapped_for_y.sender
    }

    public fun x_swapped_for_y_x_token_type(x_swapped_for_y: &XSwappedForY): String {
        x_swapped_for_y.x_token_type
    }

    public fun x_swapped_for_y_y_token_type(x_swapped_for_y: &XSwappedForY): String {
        x_swapped_for_y.y_token_type
    }

    public fun x_swapped_for_y_x_amount(x_swapped_for_y: &XSwappedForY): u64 {
        x_swapped_for_y.x_amount
    }

    public fun x_swapped_for_y_y_amount(x_swapped_for_y: &XSwappedForY): u64 {
        x_swapped_for_y.y_amount
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_x_swapped_for_y<X, Y>(
        token_pair: &TokenPair<X, Y>,
        sender: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
    ): XSwappedForY {
        XSwappedForY {
            id: id(token_pair),
            version: version(token_pair),
            sender,
            x_token_type,
            y_token_type,
            x_amount,
            y_amount,
        }
    }


    public(friend) fun transfer_object<X, Y>(token_pair: TokenPair<X, Y>, recipient: address) {
        assert!(token_pair.version == 0, EInappropriateVersion);
        transfer::transfer(token_pair, recipient);
    }

    public(friend) fun update_version_and_transfer_object<X, Y>(token_pair: TokenPair<X, Y>, recipient: address) {
        update_object_version(&mut token_pair);
        transfer::transfer(token_pair, recipient);
    }

    #[lint_allow(share_owned)]
    public(friend) fun share_object<X, Y>(token_pair: TokenPair<X, Y>) {
        assert!(token_pair.version == 0, EInappropriateVersion);
        transfer::share_object(token_pair);
    }

    #[lint_allow(freeze_wrapped)]
    public(friend) fun freeze_object<X, Y>(token_pair: TokenPair<X, Y>) {
        assert!(token_pair.version == 0, EInappropriateVersion);
        transfer::freeze_object(token_pair);
    }

    #[lint_allow(freeze_wrapped)]
    public(friend) fun update_version_and_freeze_object<X, Y>(token_pair: TokenPair<X, Y>) {
        update_object_version(&mut token_pair);
        transfer::freeze_object(token_pair);
    }

    public(friend) fun update_object_version<X, Y>(token_pair: &mut TokenPair<X, Y>) {
        token_pair.version = token_pair.version + 1;
        //assert!(token_pair.version != 0, EInappropriateVersion);
    }

    public(friend) fun drop_token_pair<X, Y>(token_pair: TokenPair<X, Y>) {
        let TokenPair {
            id,
            version: _version,
            schema_version: _,
            admin_cap: _,
            x_reserve,
            y_reserve,
            exchange_rate_numerator: _exchange_rate_numerator,
            exchange_rate_denominator: _exchange_rate_denominator,
            liquidity_token_id: _liquidity_token_id,
        } = token_pair;
        object::delete(id);
        sui::balance::destroy_zero(x_reserve);
        sui::balance::destroy_zero(y_reserve);
    }

    public(friend) fun emit_token_pair_initialized(token_pair_initialized: TokenPairInitialized) {
        assert!(std::option::is_some(&token_pair_initialized.id), EEmptyObjectID);
        event::emit(token_pair_initialized);
    }

    public(friend) fun emit_exchange_rate_updated(exchange_rate_updated: ExchangeRateUpdated) {
        event::emit(exchange_rate_updated);
    }

    public(friend) fun emit_y_reserve_deposited(y_reserve_deposited: YReserveDeposited) {
        event::emit(y_reserve_deposited);
    }

    public(friend) fun emit_x_reserve_withdrawn(x_reserve_withdrawn: XReserveWithdrawn) {
        event::emit(x_reserve_withdrawn);
    }

    public(friend) fun emit_y_reserve_withdrawn(y_reserve_withdrawn: YReserveWithdrawn) {
        event::emit(y_reserve_withdrawn);
    }

    public(friend) fun emit_x_swapped_for_y(x_swapped_for_y: XSwappedForY) {
        event::emit(x_swapped_for_y);
    }

}
