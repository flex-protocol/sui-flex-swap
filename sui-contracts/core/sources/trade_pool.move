// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module sui_swap_core::trade_pool {
    use std::option::{Self, Option};
    use std::string::String;
    use sui::balance::Balance;
    use sui::event;
    use sui::object::{Self, ID, UID};
    use sui::object_table::ObjectTable;
    use sui::table::Table;
    use sui::transfer;
    use sui::tx_context::TxContext;

    struct TRADE_POOL has drop {}

    friend sui_swap_core::trade_pool_initialize_trade_pool_logic;
    friend sui_swap_core::trade_pool_initialize_sell_pool_logic;
    friend sui_swap_core::trade_pool_initialize_buy_pool_logic;
    friend sui_swap_core::trade_pool_update_exchange_rate_logic;
    friend sui_swap_core::trade_pool_add_x_token_logic;
    friend sui_swap_core::trade_pool_remove_x_token_logic;
    friend sui_swap_core::trade_pool_deposit_y_reserve_logic;
    friend sui_swap_core::trade_pool_withdraw_y_reserve_logic;
    friend sui_swap_core::trade_pool_destroy_logic;
    friend sui_swap_core::trade_pool_buy_x_logic;
    friend sui_swap_core::trade_pool_sell_x_logic;
    friend sui_swap_core::trade_pool_aggregate;

    #[allow(unused_const)]
    const EDataTooLong: u64 = 102;
    const EInappropriateVersion: u64 = 103;
    const EInvalidEnumValue: u64 = 106;
    const EEmptyObjectID: u64 = 107;

    /// Not the right admin for the object
    const ENotAdmin: u64 = 0;
    /// Migration is not an upgrade
    const ENotUpgrade: u64 = 1;
    /// Calling functions from the wrong package version
    const EWrongSchemaVersion: u64 = 2;

    const SCHEMA_VERSION: u64 = 0;

    struct AdminCap has key {
        id: UID,
    }


    fun init(otw: TRADE_POOL, ctx: &mut TxContext) {
        sui::package::claim_and_keep(otw, ctx)
    }

    public fun assert_schema_version<X: key + store, Y>(trade_pool: &TradePool<X, Y>) {
        assert!(trade_pool.schema_version == SCHEMA_VERSION, EWrongSchemaVersion);
    }

    struct TradePool<phantom X: key + store, phantom Y> has key {
        id: UID,
        version: u64,
        schema_version: u64,
        admin_cap: ID,
        pool_type: u8,
        x_reserve: ObjectTable<ID, X>,
        x_amounts: Table<ID, u64>,
        x_total_amount: u64,
        y_reserve: Balance<Y>,
        liquidity_token_id: ID,
        x_sold_amount: u64,
        x_bought_amount: u64,
        start_exchange_rate_numerator: u64,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_curve_type: u8,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
    }

    public fun id<X: key + store, Y>(trade_pool: &TradePool<X, Y>): object::ID {
        object::uid_to_inner(&trade_pool.id)
    }

    public fun version<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.version
    }

    public fun pool_type<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u8 {
        trade_pool.pool_type
    }

    public(friend) fun set_pool_type<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, pool_type: u8) {
        assert!(sui_swap_core::pool_type::is_valid(pool_type), EInvalidEnumValue);
        trade_pool.pool_type = pool_type;
    }

    public fun borrow_x_reserve<X: key + store, Y>(trade_pool: &TradePool<X, Y>): &ObjectTable<ID, X> {
        &trade_pool.x_reserve
    }

    public(friend) fun borrow_mut_x_reserve<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>): &mut ObjectTable<ID, X> {
        &mut trade_pool.x_reserve
    }

    public fun borrow_x_amounts<X: key + store, Y>(trade_pool: &TradePool<X, Y>): &Table<ID, u64> {
        &trade_pool.x_amounts
    }

    public(friend) fun borrow_mut_x_amounts<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>): &mut Table<ID, u64> {
        &mut trade_pool.x_amounts
    }

    public fun x_total_amount<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.x_total_amount
    }

    public(friend) fun set_x_total_amount<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, x_total_amount: u64) {
        trade_pool.x_total_amount = x_total_amount;
    }

    public fun borrow_y_reserve<X: key + store, Y>(trade_pool: &TradePool<X, Y>): &Balance<Y> {
        &trade_pool.y_reserve
    }

    public(friend) fun borrow_mut_y_reserve<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>): &mut Balance<Y> {
        &mut trade_pool.y_reserve
    }

    public fun liquidity_token_id<X: key + store, Y>(trade_pool: &TradePool<X, Y>): ID {
        trade_pool.liquidity_token_id
    }

    public(friend) fun set_liquidity_token_id<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, liquidity_token_id: ID) {
        trade_pool.liquidity_token_id = liquidity_token_id;
    }

    public fun x_sold_amount<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.x_sold_amount
    }

    public(friend) fun set_x_sold_amount<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, x_sold_amount: u64) {
        trade_pool.x_sold_amount = x_sold_amount;
    }

    public fun x_bought_amount<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.x_bought_amount
    }

    public(friend) fun set_x_bought_amount<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, x_bought_amount: u64) {
        trade_pool.x_bought_amount = x_bought_amount;
    }

    public fun start_exchange_rate_numerator<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.start_exchange_rate_numerator
    }

    public(friend) fun set_start_exchange_rate_numerator<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, start_exchange_rate_numerator: u64) {
        trade_pool.start_exchange_rate_numerator = start_exchange_rate_numerator;
    }

    public fun exchange_rate_numerator<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.exchange_rate_numerator
    }

    public(friend) fun set_exchange_rate_numerator<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, exchange_rate_numerator: u64) {
        trade_pool.exchange_rate_numerator = exchange_rate_numerator;
    }

    public fun exchange_rate_denominator<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.exchange_rate_denominator
    }

    public(friend) fun set_exchange_rate_denominator<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, exchange_rate_denominator: u64) {
        trade_pool.exchange_rate_denominator = exchange_rate_denominator;
    }

    public fun price_curve_type<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u8 {
        trade_pool.price_curve_type
    }

    public(friend) fun set_price_curve_type<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, price_curve_type: u8) {
        trade_pool.price_curve_type = price_curve_type;
    }

    public fun price_delta_x_amount<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.price_delta_x_amount
    }

    public(friend) fun set_price_delta_x_amount<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, price_delta_x_amount: u64) {
        trade_pool.price_delta_x_amount = price_delta_x_amount;
    }

    public fun price_delta_numerator<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.price_delta_numerator
    }

    public(friend) fun set_price_delta_numerator<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, price_delta_numerator: u64) {
        trade_pool.price_delta_numerator = price_delta_numerator;
    }

    public fun price_delta_denominator<X: key + store, Y>(trade_pool: &TradePool<X, Y>): u64 {
        trade_pool.price_delta_denominator
    }

    public(friend) fun set_price_delta_denominator<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, price_delta_denominator: u64) {
        trade_pool.price_delta_denominator = price_delta_denominator;
    }

    public fun admin_cap<X: key + store, Y>(trade_pool: &TradePool<X, Y>): ID {
        trade_pool.admin_cap
    }

    public(friend) fun new_trade_pool<X: key + store, Y>(
        pool_type: u8,
        x_reserve: ObjectTable<ID, X>,
        x_amounts: Table<ID, u64>,
        x_total_amount: u64,
        liquidity_token_id: ID,
        x_sold_amount: u64,
        x_bought_amount: u64,
        start_exchange_rate_numerator: u64,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_curve_type: u8,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        ctx: &mut TxContext,
    ): TradePool<X, Y> {
        assert!(sui_swap_core::pool_type::is_valid(pool_type), EInvalidEnumValue);
        let admin_cap = AdminCap {
            id: object::new(ctx),
        };
        let admin_cap_id = object::id(&admin_cap);
        transfer::transfer(admin_cap, sui::tx_context::sender(ctx));
        TradePool {
            id: object::new(ctx),
            version: 0,
            schema_version: SCHEMA_VERSION,
            admin_cap: admin_cap_id,
            pool_type,
            x_reserve,
            x_amounts,
            x_total_amount,
            y_reserve: sui::balance::zero(),
            liquidity_token_id,
            x_sold_amount,
            x_bought_amount,
            start_exchange_rate_numerator,
            exchange_rate_numerator,
            exchange_rate_denominator,
            price_curve_type,
            price_delta_x_amount,
            price_delta_numerator,
            price_delta_denominator,
        }
    }

    entry fun migrate<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>, a: &AdminCap) {
        assert!(trade_pool.admin_cap == object::id(a), ENotAdmin);
        assert!(trade_pool.schema_version < SCHEMA_VERSION, ENotUpgrade);
        trade_pool.schema_version = SCHEMA_VERSION;
    }

    struct TradePoolInitialized has copy, drop {
        id: option::Option<object::ID>,
        exchange_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_curve_type: u8,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
        liquidity_token_id: Option<ID>,
        x_id: ID,
    }

    public fun trade_pool_initialized_id(trade_pool_initialized: &TradePoolInitialized): option::Option<object::ID> {
        trade_pool_initialized.id
    }

    public(friend) fun set_trade_pool_initialized_id(trade_pool_initialized: &mut TradePoolInitialized, id: object::ID) {
        trade_pool_initialized.id = option::some(id);
    }

    public fun trade_pool_initialized_exchange_id(trade_pool_initialized: &TradePoolInitialized): ID {
        trade_pool_initialized.exchange_id
    }

    public fun trade_pool_initialized_exchange_rate_numerator(trade_pool_initialized: &TradePoolInitialized): u64 {
        trade_pool_initialized.exchange_rate_numerator
    }

    public fun trade_pool_initialized_exchange_rate_denominator(trade_pool_initialized: &TradePoolInitialized): u64 {
        trade_pool_initialized.exchange_rate_denominator
    }

    public fun trade_pool_initialized_price_curve_type(trade_pool_initialized: &TradePoolInitialized): u8 {
        trade_pool_initialized.price_curve_type
    }

    public fun trade_pool_initialized_price_delta_x_amount(trade_pool_initialized: &TradePoolInitialized): u64 {
        trade_pool_initialized.price_delta_x_amount
    }

    public fun trade_pool_initialized_price_delta_numerator(trade_pool_initialized: &TradePoolInitialized): u64 {
        trade_pool_initialized.price_delta_numerator
    }

    public fun trade_pool_initialized_price_delta_denominator(trade_pool_initialized: &TradePoolInitialized): u64 {
        trade_pool_initialized.price_delta_denominator
    }

    public fun trade_pool_initialized_provider(trade_pool_initialized: &TradePoolInitialized): address {
        trade_pool_initialized.provider
    }

    public fun trade_pool_initialized_x_token_type(trade_pool_initialized: &TradePoolInitialized): String {
        trade_pool_initialized.x_token_type
    }

    public fun trade_pool_initialized_y_token_type(trade_pool_initialized: &TradePoolInitialized): String {
        trade_pool_initialized.y_token_type
    }

    public fun trade_pool_initialized_x_amount(trade_pool_initialized: &TradePoolInitialized): u64 {
        trade_pool_initialized.x_amount
    }

    public fun trade_pool_initialized_y_amount(trade_pool_initialized: &TradePoolInitialized): u64 {
        trade_pool_initialized.y_amount
    }

    public fun trade_pool_initialized_liquidity_token_id(trade_pool_initialized: &TradePoolInitialized): Option<ID> {
        trade_pool_initialized.liquidity_token_id
    }

    public(friend) fun set_trade_pool_initialized_liquidity_token_id(trade_pool_initialized: &mut TradePoolInitialized, liquidity_token_id: ID) {
        trade_pool_initialized.liquidity_token_id = option::some(liquidity_token_id);
    }

    public fun trade_pool_initialized_x_id(trade_pool_initialized: &TradePoolInitialized): ID {
        trade_pool_initialized.x_id
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_trade_pool_initialized<X: key + store, Y>(
        exchange_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_curve_type: u8,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
        liquidity_token_id: Option<ID>,
        x_id: ID,
    ): TradePoolInitialized {
        TradePoolInitialized {
            id: option::none(),
            exchange_id,
            exchange_rate_numerator,
            exchange_rate_denominator,
            price_curve_type,
            price_delta_x_amount,
            price_delta_numerator,
            price_delta_denominator,
            provider,
            x_token_type,
            y_token_type,
            x_amount,
            y_amount,
            liquidity_token_id,
            x_id,
        }
    }

    struct SellPoolInitialized has copy, drop {
        id: option::Option<object::ID>,
        exchange_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_curve_type: u8,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        liquidity_token_id: Option<ID>,
        x_id: ID,
    }

    public fun sell_pool_initialized_id(sell_pool_initialized: &SellPoolInitialized): option::Option<object::ID> {
        sell_pool_initialized.id
    }

    public(friend) fun set_sell_pool_initialized_id(sell_pool_initialized: &mut SellPoolInitialized, id: object::ID) {
        sell_pool_initialized.id = option::some(id);
    }

    public fun sell_pool_initialized_exchange_id(sell_pool_initialized: &SellPoolInitialized): ID {
        sell_pool_initialized.exchange_id
    }

    public fun sell_pool_initialized_exchange_rate_numerator(sell_pool_initialized: &SellPoolInitialized): u64 {
        sell_pool_initialized.exchange_rate_numerator
    }

    public fun sell_pool_initialized_exchange_rate_denominator(sell_pool_initialized: &SellPoolInitialized): u64 {
        sell_pool_initialized.exchange_rate_denominator
    }

    public fun sell_pool_initialized_price_curve_type(sell_pool_initialized: &SellPoolInitialized): u8 {
        sell_pool_initialized.price_curve_type
    }

    public fun sell_pool_initialized_price_delta_x_amount(sell_pool_initialized: &SellPoolInitialized): u64 {
        sell_pool_initialized.price_delta_x_amount
    }

    public fun sell_pool_initialized_price_delta_numerator(sell_pool_initialized: &SellPoolInitialized): u64 {
        sell_pool_initialized.price_delta_numerator
    }

    public fun sell_pool_initialized_price_delta_denominator(sell_pool_initialized: &SellPoolInitialized): u64 {
        sell_pool_initialized.price_delta_denominator
    }

    public fun sell_pool_initialized_provider(sell_pool_initialized: &SellPoolInitialized): address {
        sell_pool_initialized.provider
    }

    public fun sell_pool_initialized_x_token_type(sell_pool_initialized: &SellPoolInitialized): String {
        sell_pool_initialized.x_token_type
    }

    public fun sell_pool_initialized_y_token_type(sell_pool_initialized: &SellPoolInitialized): String {
        sell_pool_initialized.y_token_type
    }

    public fun sell_pool_initialized_x_amount(sell_pool_initialized: &SellPoolInitialized): u64 {
        sell_pool_initialized.x_amount
    }

    public fun sell_pool_initialized_liquidity_token_id(sell_pool_initialized: &SellPoolInitialized): Option<ID> {
        sell_pool_initialized.liquidity_token_id
    }

    public(friend) fun set_sell_pool_initialized_liquidity_token_id(sell_pool_initialized: &mut SellPoolInitialized, liquidity_token_id: ID) {
        sell_pool_initialized.liquidity_token_id = option::some(liquidity_token_id);
    }

    public fun sell_pool_initialized_x_id(sell_pool_initialized: &SellPoolInitialized): ID {
        sell_pool_initialized.x_id
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_sell_pool_initialized<X: key + store, Y>(
        exchange_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_curve_type: u8,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        liquidity_token_id: Option<ID>,
        x_id: ID,
    ): SellPoolInitialized {
        SellPoolInitialized {
            id: option::none(),
            exchange_id,
            exchange_rate_numerator,
            exchange_rate_denominator,
            price_curve_type,
            price_delta_x_amount,
            price_delta_numerator,
            price_delta_denominator,
            provider,
            x_token_type,
            y_token_type,
            x_amount,
            liquidity_token_id,
            x_id,
        }
    }

    struct BuyPoolInitialized has copy, drop {
        id: option::Option<object::ID>,
        exchange_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_curve_type: u8,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        y_amount: u64,
        liquidity_token_id: Option<ID>,
    }

    public fun buy_pool_initialized_id(buy_pool_initialized: &BuyPoolInitialized): option::Option<object::ID> {
        buy_pool_initialized.id
    }

    public(friend) fun set_buy_pool_initialized_id(buy_pool_initialized: &mut BuyPoolInitialized, id: object::ID) {
        buy_pool_initialized.id = option::some(id);
    }

    public fun buy_pool_initialized_exchange_id(buy_pool_initialized: &BuyPoolInitialized): ID {
        buy_pool_initialized.exchange_id
    }

    public fun buy_pool_initialized_exchange_rate_numerator(buy_pool_initialized: &BuyPoolInitialized): u64 {
        buy_pool_initialized.exchange_rate_numerator
    }

    public fun buy_pool_initialized_exchange_rate_denominator(buy_pool_initialized: &BuyPoolInitialized): u64 {
        buy_pool_initialized.exchange_rate_denominator
    }

    public fun buy_pool_initialized_price_curve_type(buy_pool_initialized: &BuyPoolInitialized): u8 {
        buy_pool_initialized.price_curve_type
    }

    public fun buy_pool_initialized_price_delta_x_amount(buy_pool_initialized: &BuyPoolInitialized): u64 {
        buy_pool_initialized.price_delta_x_amount
    }

    public fun buy_pool_initialized_price_delta_numerator(buy_pool_initialized: &BuyPoolInitialized): u64 {
        buy_pool_initialized.price_delta_numerator
    }

    public fun buy_pool_initialized_price_delta_denominator(buy_pool_initialized: &BuyPoolInitialized): u64 {
        buy_pool_initialized.price_delta_denominator
    }

    public fun buy_pool_initialized_provider(buy_pool_initialized: &BuyPoolInitialized): address {
        buy_pool_initialized.provider
    }

    public fun buy_pool_initialized_x_token_type(buy_pool_initialized: &BuyPoolInitialized): String {
        buy_pool_initialized.x_token_type
    }

    public fun buy_pool_initialized_y_token_type(buy_pool_initialized: &BuyPoolInitialized): String {
        buy_pool_initialized.y_token_type
    }

    public fun buy_pool_initialized_y_amount(buy_pool_initialized: &BuyPoolInitialized): u64 {
        buy_pool_initialized.y_amount
    }

    public fun buy_pool_initialized_liquidity_token_id(buy_pool_initialized: &BuyPoolInitialized): Option<ID> {
        buy_pool_initialized.liquidity_token_id
    }

    public(friend) fun set_buy_pool_initialized_liquidity_token_id(buy_pool_initialized: &mut BuyPoolInitialized, liquidity_token_id: ID) {
        buy_pool_initialized.liquidity_token_id = option::some(liquidity_token_id);
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_buy_pool_initialized<X: key + store, Y>(
        exchange_id: ID,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_curve_type: u8,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        y_amount: u64,
        liquidity_token_id: Option<ID>,
    ): BuyPoolInitialized {
        BuyPoolInitialized {
            id: option::none(),
            exchange_id,
            exchange_rate_numerator,
            exchange_rate_denominator,
            price_curve_type,
            price_delta_x_amount,
            price_delta_numerator,
            price_delta_denominator,
            provider,
            x_token_type,
            y_token_type,
            y_amount,
            liquidity_token_id,
        }
    }

    struct PoolExchangeRateUpdated has copy, drop {
        id: object::ID,
        version: u64,
        liquidity_token_id: ID,
        start_exchange_rate_numerator: u64,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
    }

    public fun pool_exchange_rate_updated_id(pool_exchange_rate_updated: &PoolExchangeRateUpdated): object::ID {
        pool_exchange_rate_updated.id
    }

    public fun pool_exchange_rate_updated_liquidity_token_id(pool_exchange_rate_updated: &PoolExchangeRateUpdated): ID {
        pool_exchange_rate_updated.liquidity_token_id
    }

    public fun pool_exchange_rate_updated_start_exchange_rate_numerator(pool_exchange_rate_updated: &PoolExchangeRateUpdated): u64 {
        pool_exchange_rate_updated.start_exchange_rate_numerator
    }

    public fun pool_exchange_rate_updated_exchange_rate_numerator(pool_exchange_rate_updated: &PoolExchangeRateUpdated): u64 {
        pool_exchange_rate_updated.exchange_rate_numerator
    }

    public fun pool_exchange_rate_updated_exchange_rate_denominator(pool_exchange_rate_updated: &PoolExchangeRateUpdated): u64 {
        pool_exchange_rate_updated.exchange_rate_denominator
    }

    public fun pool_exchange_rate_updated_price_delta_x_amount(pool_exchange_rate_updated: &PoolExchangeRateUpdated): u64 {
        pool_exchange_rate_updated.price_delta_x_amount
    }

    public fun pool_exchange_rate_updated_price_delta_numerator(pool_exchange_rate_updated: &PoolExchangeRateUpdated): u64 {
        pool_exchange_rate_updated.price_delta_numerator
    }

    public fun pool_exchange_rate_updated_price_delta_denominator(pool_exchange_rate_updated: &PoolExchangeRateUpdated): u64 {
        pool_exchange_rate_updated.price_delta_denominator
    }

    public fun pool_exchange_rate_updated_provider(pool_exchange_rate_updated: &PoolExchangeRateUpdated): address {
        pool_exchange_rate_updated.provider
    }

    public fun pool_exchange_rate_updated_x_token_type(pool_exchange_rate_updated: &PoolExchangeRateUpdated): String {
        pool_exchange_rate_updated.x_token_type
    }

    public fun pool_exchange_rate_updated_y_token_type(pool_exchange_rate_updated: &PoolExchangeRateUpdated): String {
        pool_exchange_rate_updated.y_token_type
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_pool_exchange_rate_updated<X: key + store, Y>(
        trade_pool: &TradePool<X, Y>,
        liquidity_token_id: ID,
        start_exchange_rate_numerator: u64,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        provider: address,
        x_token_type: String,
        y_token_type: String,
    ): PoolExchangeRateUpdated {
        PoolExchangeRateUpdated {
            id: id(trade_pool),
            version: version(trade_pool),
            liquidity_token_id,
            start_exchange_rate_numerator,
            exchange_rate_numerator,
            exchange_rate_denominator,
            price_delta_x_amount,
            price_delta_numerator,
            price_delta_denominator,
            provider,
            x_token_type,
            y_token_type,
        }
    }

    struct PoolXTokenAdded has copy, drop {
        id: object::ID,
        version: u64,
        liquidity_token_id: ID,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        x_id: ID,
    }

    public fun pool_x_token_added_id(pool_x_token_added: &PoolXTokenAdded): object::ID {
        pool_x_token_added.id
    }

    public fun pool_x_token_added_liquidity_token_id(pool_x_token_added: &PoolXTokenAdded): ID {
        pool_x_token_added.liquidity_token_id
    }

    public fun pool_x_token_added_provider(pool_x_token_added: &PoolXTokenAdded): address {
        pool_x_token_added.provider
    }

    public fun pool_x_token_added_x_token_type(pool_x_token_added: &PoolXTokenAdded): String {
        pool_x_token_added.x_token_type
    }

    public fun pool_x_token_added_y_token_type(pool_x_token_added: &PoolXTokenAdded): String {
        pool_x_token_added.y_token_type
    }

    public fun pool_x_token_added_x_amount(pool_x_token_added: &PoolXTokenAdded): u64 {
        pool_x_token_added.x_amount
    }

    public fun pool_x_token_added_x_id(pool_x_token_added: &PoolXTokenAdded): ID {
        pool_x_token_added.x_id
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_pool_x_token_added<X: key + store, Y>(
        trade_pool: &TradePool<X, Y>,
        liquidity_token_id: ID,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        x_id: ID,
    ): PoolXTokenAdded {
        PoolXTokenAdded {
            id: id(trade_pool),
            version: version(trade_pool),
            liquidity_token_id,
            provider,
            x_token_type,
            y_token_type,
            x_amount,
            x_id,
        }
    }

    struct PoolXTokenRemoved has copy, drop {
        id: object::ID,
        version: u64,
        liquidity_token_id: ID,
        x_id: ID,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
    }

    public fun pool_x_token_removed_id(pool_x_token_removed: &PoolXTokenRemoved): object::ID {
        pool_x_token_removed.id
    }

    public fun pool_x_token_removed_liquidity_token_id(pool_x_token_removed: &PoolXTokenRemoved): ID {
        pool_x_token_removed.liquidity_token_id
    }

    public fun pool_x_token_removed_x_id(pool_x_token_removed: &PoolXTokenRemoved): ID {
        pool_x_token_removed.x_id
    }

    public fun pool_x_token_removed_provider(pool_x_token_removed: &PoolXTokenRemoved): address {
        pool_x_token_removed.provider
    }

    public fun pool_x_token_removed_x_token_type(pool_x_token_removed: &PoolXTokenRemoved): String {
        pool_x_token_removed.x_token_type
    }

    public fun pool_x_token_removed_y_token_type(pool_x_token_removed: &PoolXTokenRemoved): String {
        pool_x_token_removed.y_token_type
    }

    public fun pool_x_token_removed_x_amount(pool_x_token_removed: &PoolXTokenRemoved): u64 {
        pool_x_token_removed.x_amount
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_pool_x_token_removed<X: key + store, Y>(
        trade_pool: &TradePool<X, Y>,
        liquidity_token_id: ID,
        x_id: ID,
        provider: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
    ): PoolXTokenRemoved {
        PoolXTokenRemoved {
            id: id(trade_pool),
            version: version(trade_pool),
            liquidity_token_id,
            x_id,
            provider,
            x_token_type,
            y_token_type,
            x_amount,
        }
    }

    struct PoolYReserveDeposited has copy, drop {
        id: object::ID,
        version: u64,
        liquidity_token_id: ID,
        x_token_type: String,
        y_token_type: String,
        y_amount: u64,
    }

    public fun pool_y_reserve_deposited_id(pool_y_reserve_deposited: &PoolYReserveDeposited): object::ID {
        pool_y_reserve_deposited.id
    }

    public fun pool_y_reserve_deposited_liquidity_token_id(pool_y_reserve_deposited: &PoolYReserveDeposited): ID {
        pool_y_reserve_deposited.liquidity_token_id
    }

    public fun pool_y_reserve_deposited_x_token_type(pool_y_reserve_deposited: &PoolYReserveDeposited): String {
        pool_y_reserve_deposited.x_token_type
    }

    public fun pool_y_reserve_deposited_y_token_type(pool_y_reserve_deposited: &PoolYReserveDeposited): String {
        pool_y_reserve_deposited.y_token_type
    }

    public fun pool_y_reserve_deposited_y_amount(pool_y_reserve_deposited: &PoolYReserveDeposited): u64 {
        pool_y_reserve_deposited.y_amount
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_pool_y_reserve_deposited<X: key + store, Y>(
        trade_pool: &TradePool<X, Y>,
        liquidity_token_id: ID,
        x_token_type: String,
        y_token_type: String,
        y_amount: u64,
    ): PoolYReserveDeposited {
        PoolYReserveDeposited {
            id: id(trade_pool),
            version: version(trade_pool),
            liquidity_token_id,
            x_token_type,
            y_token_type,
            y_amount,
        }
    }

    struct PoolYReserveWithdrawn has copy, drop {
        id: object::ID,
        version: u64,
        liquidity_token_id: ID,
        y_amount: u64,
        x_token_type: String,
        y_token_type: String,
    }

    public fun pool_y_reserve_withdrawn_id(pool_y_reserve_withdrawn: &PoolYReserveWithdrawn): object::ID {
        pool_y_reserve_withdrawn.id
    }

    public fun pool_y_reserve_withdrawn_liquidity_token_id(pool_y_reserve_withdrawn: &PoolYReserveWithdrawn): ID {
        pool_y_reserve_withdrawn.liquidity_token_id
    }

    public fun pool_y_reserve_withdrawn_y_amount(pool_y_reserve_withdrawn: &PoolYReserveWithdrawn): u64 {
        pool_y_reserve_withdrawn.y_amount
    }

    public fun pool_y_reserve_withdrawn_x_token_type(pool_y_reserve_withdrawn: &PoolYReserveWithdrawn): String {
        pool_y_reserve_withdrawn.x_token_type
    }

    public fun pool_y_reserve_withdrawn_y_token_type(pool_y_reserve_withdrawn: &PoolYReserveWithdrawn): String {
        pool_y_reserve_withdrawn.y_token_type
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_pool_y_reserve_withdrawn<X: key + store, Y>(
        trade_pool: &TradePool<X, Y>,
        liquidity_token_id: ID,
        y_amount: u64,
        x_token_type: String,
        y_token_type: String,
    ): PoolYReserveWithdrawn {
        PoolYReserveWithdrawn {
            id: id(trade_pool),
            version: version(trade_pool),
            liquidity_token_id,
            y_amount,
            x_token_type,
            y_token_type,
        }
    }

    struct PoolDestroyed has copy, drop {
        id: object::ID,
        version: u64,
        liquidity_token_id: ID,
    }

    public fun pool_destroyed_id(pool_destroyed: &PoolDestroyed): object::ID {
        pool_destroyed.id
    }

    public fun pool_destroyed_liquidity_token_id(pool_destroyed: &PoolDestroyed): ID {
        pool_destroyed.liquidity_token_id
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_pool_destroyed<X: key + store, Y>(
        trade_pool: &TradePool<X, Y>,
        liquidity_token_id: ID,
    ): PoolDestroyed {
        PoolDestroyed {
            id: id(trade_pool),
            version: version(trade_pool),
            liquidity_token_id,
        }
    }

    struct PoolYSwappedForX has copy, drop {
        id: object::ID,
        version: u64,
        x_id: ID,
        sender: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
        new_exchange_rate_numerator: u64,
    }

    public fun pool_y_swapped_for_x_id(pool_y_swapped_for_x: &PoolYSwappedForX): object::ID {
        pool_y_swapped_for_x.id
    }

    public fun pool_y_swapped_for_x_x_id(pool_y_swapped_for_x: &PoolYSwappedForX): ID {
        pool_y_swapped_for_x.x_id
    }

    public fun pool_y_swapped_for_x_sender(pool_y_swapped_for_x: &PoolYSwappedForX): address {
        pool_y_swapped_for_x.sender
    }

    public fun pool_y_swapped_for_x_x_token_type(pool_y_swapped_for_x: &PoolYSwappedForX): String {
        pool_y_swapped_for_x.x_token_type
    }

    public fun pool_y_swapped_for_x_y_token_type(pool_y_swapped_for_x: &PoolYSwappedForX): String {
        pool_y_swapped_for_x.y_token_type
    }

    public fun pool_y_swapped_for_x_x_amount(pool_y_swapped_for_x: &PoolYSwappedForX): u64 {
        pool_y_swapped_for_x.x_amount
    }

    public fun pool_y_swapped_for_x_y_amount(pool_y_swapped_for_x: &PoolYSwappedForX): u64 {
        pool_y_swapped_for_x.y_amount
    }

    public fun pool_y_swapped_for_x_new_exchange_rate_numerator(pool_y_swapped_for_x: &PoolYSwappedForX): u64 {
        pool_y_swapped_for_x.new_exchange_rate_numerator
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_pool_y_swapped_for_x<X: key + store, Y>(
        trade_pool: &TradePool<X, Y>,
        x_id: ID,
        sender: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
        new_exchange_rate_numerator: u64,
    ): PoolYSwappedForX {
        PoolYSwappedForX {
            id: id(trade_pool),
            version: version(trade_pool),
            x_id,
            sender,
            x_token_type,
            y_token_type,
            x_amount,
            y_amount,
            new_exchange_rate_numerator,
        }
    }

    struct PoolXSwappedForY has copy, drop {
        id: object::ID,
        version: u64,
        expected_y_amount_out: u64,
        sender: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
        x_id: ID,
        new_exchange_rate_numerator: u64,
    }

    public fun pool_x_swapped_for_y_id(pool_x_swapped_for_y: &PoolXSwappedForY): object::ID {
        pool_x_swapped_for_y.id
    }

    public fun pool_x_swapped_for_y_expected_y_amount_out(pool_x_swapped_for_y: &PoolXSwappedForY): u64 {
        pool_x_swapped_for_y.expected_y_amount_out
    }

    public fun pool_x_swapped_for_y_sender(pool_x_swapped_for_y: &PoolXSwappedForY): address {
        pool_x_swapped_for_y.sender
    }

    public fun pool_x_swapped_for_y_x_token_type(pool_x_swapped_for_y: &PoolXSwappedForY): String {
        pool_x_swapped_for_y.x_token_type
    }

    public fun pool_x_swapped_for_y_y_token_type(pool_x_swapped_for_y: &PoolXSwappedForY): String {
        pool_x_swapped_for_y.y_token_type
    }

    public fun pool_x_swapped_for_y_x_amount(pool_x_swapped_for_y: &PoolXSwappedForY): u64 {
        pool_x_swapped_for_y.x_amount
    }

    public fun pool_x_swapped_for_y_y_amount(pool_x_swapped_for_y: &PoolXSwappedForY): u64 {
        pool_x_swapped_for_y.y_amount
    }

    public fun pool_x_swapped_for_y_x_id(pool_x_swapped_for_y: &PoolXSwappedForY): ID {
        pool_x_swapped_for_y.x_id
    }

    public fun pool_x_swapped_for_y_new_exchange_rate_numerator(pool_x_swapped_for_y: &PoolXSwappedForY): u64 {
        pool_x_swapped_for_y.new_exchange_rate_numerator
    }

    #[allow(unused_type_parameter)]
    public(friend) fun new_pool_x_swapped_for_y<X: key + store, Y>(
        trade_pool: &TradePool<X, Y>,
        expected_y_amount_out: u64,
        sender: address,
        x_token_type: String,
        y_token_type: String,
        x_amount: u64,
        y_amount: u64,
        x_id: ID,
        new_exchange_rate_numerator: u64,
    ): PoolXSwappedForY {
        PoolXSwappedForY {
            id: id(trade_pool),
            version: version(trade_pool),
            expected_y_amount_out,
            sender,
            x_token_type,
            y_token_type,
            x_amount,
            y_amount,
            x_id,
            new_exchange_rate_numerator,
        }
    }


    public(friend) fun transfer_object<X: key + store, Y>(trade_pool: TradePool<X, Y>, recipient: address) {
        assert!(trade_pool.version == 0, EInappropriateVersion);
        transfer::transfer(trade_pool, recipient);
    }

    public(friend) fun update_version_and_transfer_object<X: key + store, Y>(trade_pool: TradePool<X, Y>, recipient: address) {
        update_object_version(&mut trade_pool);
        transfer::transfer(trade_pool, recipient);
    }

    #[lint_allow(share_owned)]
    public fun share_object<X: key + store, Y>(trade_pool: TradePool<X, Y>) {
        assert!(trade_pool.version == 0, EInappropriateVersion);
        transfer::share_object(trade_pool);
    }

    #[lint_allow(freeze_wrapped)]
    public(friend) fun freeze_object<X: key + store, Y>(trade_pool: TradePool<X, Y>) {
        assert!(trade_pool.version == 0, EInappropriateVersion);
        transfer::freeze_object(trade_pool);
    }

    #[lint_allow(freeze_wrapped)]
    public(friend) fun update_version_and_freeze_object<X: key + store, Y>(trade_pool: TradePool<X, Y>) {
        update_object_version(&mut trade_pool);
        transfer::freeze_object(trade_pool);
    }

    public(friend) fun update_object_version<X: key + store, Y>(trade_pool: &mut TradePool<X, Y>) {
        trade_pool.version = trade_pool.version + 1;
        //assert!(trade_pool.version != 0, EInappropriateVersion);
    }

    public(friend) fun drop_trade_pool<X: key + store, Y>(trade_pool: TradePool<X, Y>) {
        let TradePool {
            id,
            version: _version,
            schema_version: _,
            admin_cap: _,
            pool_type: _pool_type,
            x_reserve,
            x_amounts,
            x_total_amount: _x_total_amount,
            y_reserve,
            liquidity_token_id: _liquidity_token_id,
            x_sold_amount: _x_sold_amount,
            x_bought_amount: _x_bought_amount,
            start_exchange_rate_numerator: _start_exchange_rate_numerator,
            exchange_rate_numerator: _exchange_rate_numerator,
            exchange_rate_denominator: _exchange_rate_denominator,
            price_curve_type: _price_curve_type,
            price_delta_x_amount: _price_delta_x_amount,
            price_delta_numerator: _price_delta_numerator,
            price_delta_denominator: _price_delta_denominator,
        } = trade_pool;
        object::delete(id);
        sui::object_table::destroy_empty(x_reserve);
        sui::table::destroy_empty(x_amounts);
        sui::balance::destroy_zero(y_reserve);
    }

    public(friend) fun emit_trade_pool_initialized(trade_pool_initialized: TradePoolInitialized) {
        assert!(std::option::is_some(&trade_pool_initialized.id), EEmptyObjectID);
        event::emit(trade_pool_initialized);
    }

    public(friend) fun emit_sell_pool_initialized(sell_pool_initialized: SellPoolInitialized) {
        assert!(std::option::is_some(&sell_pool_initialized.id), EEmptyObjectID);
        event::emit(sell_pool_initialized);
    }

    public(friend) fun emit_buy_pool_initialized(buy_pool_initialized: BuyPoolInitialized) {
        assert!(std::option::is_some(&buy_pool_initialized.id), EEmptyObjectID);
        event::emit(buy_pool_initialized);
    }

    public(friend) fun emit_pool_exchange_rate_updated(pool_exchange_rate_updated: PoolExchangeRateUpdated) {
        event::emit(pool_exchange_rate_updated);
    }

    public(friend) fun emit_pool_x_token_added(pool_x_token_added: PoolXTokenAdded) {
        event::emit(pool_x_token_added);
    }

    public(friend) fun emit_pool_x_token_removed(pool_x_token_removed: PoolXTokenRemoved) {
        event::emit(pool_x_token_removed);
    }

    public(friend) fun emit_pool_y_reserve_deposited(pool_y_reserve_deposited: PoolYReserveDeposited) {
        event::emit(pool_y_reserve_deposited);
    }

    public(friend) fun emit_pool_y_reserve_withdrawn(pool_y_reserve_withdrawn: PoolYReserveWithdrawn) {
        event::emit(pool_y_reserve_withdrawn);
    }

    public(friend) fun emit_pool_destroyed(pool_destroyed: PoolDestroyed) {
        event::emit(pool_destroyed);
    }

    public(friend) fun emit_pool_y_swapped_for_x(pool_y_swapped_for_x: PoolYSwappedForX) {
        event::emit(pool_y_swapped_for_x);
    }

    public(friend) fun emit_pool_x_swapped_for_y(pool_x_swapped_for_y: PoolXSwappedForY) {
        event::emit(pool_x_swapped_for_y);
    }

}
