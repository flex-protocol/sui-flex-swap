// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module sui_swap_example::buy_pool_aggregate {
    use sui::balance::Balance;
    use sui::object::ID;
    use sui::tx_context;
    use sui_swap_example::buy_pool;
    use sui_swap_example::buy_pool_deposit_y_reserve_logic;
    use sui_swap_example::buy_pool_destroy_logic;
    use sui_swap_example::buy_pool_initialize_buy_pool_logic;
    use sui_swap_example::buy_pool_remove_x_token_logic;
    use sui_swap_example::buy_pool_sell_x_logic;
    use sui_swap_example::buy_pool_update_exchange_rate_logic;
    use sui_swap_example::buy_pool_withdraw_y_reserve_logic;
    use sui_swap_example::exchange::Exchange;
    use sui_swap_example::liquidity_token::LiquidityToken;

    friend sui_swap_example::token_pair_service;
    friend sui_swap_example::token_pair_service_process;
    friend sui_swap_example::sell_pool_service;
    friend sui_swap_example::sell_pool_service_process;
    friend sui_swap_example::buy_pool_service;
    friend sui_swap_example::nft_service;

    #[allow(unused_mut_parameter)]
    public fun initialize_buy_pool<X: key + store, Y>(
        exchange: &mut Exchange,
        y_amount: Balance<Y>,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_curve_type: u8,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        ctx: &mut tx_context::TxContext,
    ): (buy_pool::BuyPool<X, Y>, LiquidityToken<X, Y>) {
        let buy_pool_initialized = buy_pool_initialize_buy_pool_logic::verify<X, Y>(
            exchange,
            &y_amount,
            exchange_rate_numerator,
            exchange_rate_denominator,
            price_curve_type,
            price_delta_x_amount,
            price_delta_numerator,
            price_delta_denominator,
            ctx,
        );
        let (buy_pool, liquidity_token) = buy_pool_initialize_buy_pool_logic::mutate<X, Y>(
            &mut buy_pool_initialized,
            y_amount,
            exchange,
            ctx,
        );
        buy_pool::set_buy_pool_initialized_id(&mut buy_pool_initialized, buy_pool::id(&buy_pool));
        buy_pool::emit_buy_pool_initialized(buy_pool_initialized);
        (buy_pool, liquidity_token)
    }

    #[allow(unused_mut_parameter)]
    public entry fun update_exchange_rate<X: key + store, Y>(
        buy_pool: &mut buy_pool::BuyPool<X, Y>,
        liquidity_token: &LiquidityToken<X, Y>,
        start_exchange_rate_numerator: u64,
        exchange_rate_numerator: u64,
        exchange_rate_denominator: u64,
        price_delta_x_amount: u64,
        price_delta_numerator: u64,
        price_delta_denominator: u64,
        ctx: &mut tx_context::TxContext,
    ) {
        buy_pool::assert_schema_version(buy_pool);
        let buy_pool_exchange_rate_updated = buy_pool_update_exchange_rate_logic::verify<X, Y>(
            liquidity_token,
            start_exchange_rate_numerator,
            exchange_rate_numerator,
            exchange_rate_denominator,
            price_delta_x_amount,
            price_delta_numerator,
            price_delta_denominator,
            buy_pool,
            ctx,
        );
        buy_pool_update_exchange_rate_logic::mutate<X, Y>(
            &buy_pool_exchange_rate_updated,
            buy_pool,
            ctx,
        );
        buy_pool::update_object_version(buy_pool);
        buy_pool::emit_buy_pool_exchange_rate_updated(buy_pool_exchange_rate_updated);
    }

    #[allow(unused_mut_parameter)]
    public fun remove_x_token<X: key + store, Y>(
        buy_pool: &mut buy_pool::BuyPool<X, Y>,
        liquidity_token: &LiquidityToken<X, Y>,
        x_id: ID,
        ctx: &mut tx_context::TxContext,
    ): X {
        buy_pool::assert_schema_version(buy_pool);
        let buy_pool_x_token_removed = buy_pool_remove_x_token_logic::verify<X, Y>(
            liquidity_token,
            x_id,
            buy_pool,
            ctx,
        );
        let remove_x_token_return = buy_pool_remove_x_token_logic::mutate<X, Y>(
            &buy_pool_x_token_removed,
            buy_pool,
            ctx,
        );
        buy_pool::update_object_version(buy_pool);
        buy_pool::emit_buy_pool_x_token_removed(buy_pool_x_token_removed);
        remove_x_token_return
    }

    #[allow(unused_mut_parameter)]
    public fun deposit_y_reserve<X: key + store, Y>(
        buy_pool: &mut buy_pool::BuyPool<X, Y>,
        liquidity_token: &LiquidityToken<X, Y>,
        y_amount: Balance<Y>,
        ctx: &mut tx_context::TxContext,
    ) {
        buy_pool::assert_schema_version(buy_pool);
        let buy_pool_y_reserve_deposited = buy_pool_deposit_y_reserve_logic::verify<X, Y>(
            liquidity_token,
            &y_amount,
            buy_pool,
            ctx,
        );
        buy_pool_deposit_y_reserve_logic::mutate<X, Y>(
            &buy_pool_y_reserve_deposited,
            y_amount,
            buy_pool,
            ctx,
        );
        buy_pool::update_object_version(buy_pool);
        buy_pool::emit_buy_pool_y_reserve_deposited(buy_pool_y_reserve_deposited);
    }

    #[allow(unused_mut_parameter)]
    public fun withdraw_y_reserve<X: key + store, Y>(
        buy_pool: &mut buy_pool::BuyPool<X, Y>,
        liquidity_token: &LiquidityToken<X, Y>,
        y_amount: u64,
        ctx: &mut tx_context::TxContext,
    ): Balance<Y> {
        buy_pool::assert_schema_version(buy_pool);
        let buy_pool_y_reserve_withdrawn = buy_pool_withdraw_y_reserve_logic::verify<X, Y>(
            liquidity_token,
            y_amount,
            buy_pool,
            ctx,
        );
        let withdraw_y_reserve_return = buy_pool_withdraw_y_reserve_logic::mutate<X, Y>(
            &buy_pool_y_reserve_withdrawn,
            buy_pool,
            ctx,
        );
        buy_pool::update_object_version(buy_pool);
        buy_pool::emit_buy_pool_y_reserve_withdrawn(buy_pool_y_reserve_withdrawn);
        withdraw_y_reserve_return
    }

    #[allow(unused_mut_parameter)]
    public entry fun destroy<X: key + store, Y>(
        buy_pool: buy_pool::BuyPool<X, Y>,
        liquidity_token: &LiquidityToken<X, Y>,
        ctx: &mut tx_context::TxContext,
    ) {
        buy_pool::assert_schema_version(&buy_pool);
        let buy_pool_destroyed = buy_pool_destroy_logic::verify<X, Y>(
            liquidity_token,
            &buy_pool,
            ctx,
        );
        let updated_buy_pool = buy_pool_destroy_logic::mutate<X, Y>(
            &buy_pool_destroyed,
            buy_pool,
            ctx,
        );
        buy_pool::drop_buy_pool(updated_buy_pool);
        buy_pool::emit_buy_pool_destroyed(buy_pool_destroyed);
    }

    #[allow(unused_mut_parameter)]
    public(friend) fun sell_x<X: key + store, Y>(
        buy_pool: &mut buy_pool::BuyPool<X, Y>,
        x: X,
        x_amount: u64,
        expected_y_amount_out: u64,
        ctx: &mut tx_context::TxContext,
    ): Balance<Y> {
        buy_pool::assert_schema_version(buy_pool);
        let buy_pool_x_swapped_for_y = buy_pool_sell_x_logic::verify<X, Y>(
            &x,
            x_amount,
            expected_y_amount_out,
            buy_pool,
            ctx,
        );
        let sell_x_return = buy_pool_sell_x_logic::mutate<X, Y>(
            &buy_pool_x_swapped_for_y,
            x,
            buy_pool,
            ctx,
        );
        buy_pool::update_object_version(buy_pool);
        buy_pool::emit_buy_pool_x_swapped_for_y(buy_pool_x_swapped_for_y);
        sell_x_return
    }

}
