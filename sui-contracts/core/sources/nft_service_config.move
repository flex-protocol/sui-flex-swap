// <autogenerated>
//   This file was generated by dddappp code generator.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

module sui_swap_core::nft_service_config {
    use std::type_name::{Self, TypeName};
    use sui::object::{Self, ID, UID};
    use sui::package::{Self, Publisher};
    use sui::transfer;
    use sui::tx_context::{Self, sender, TxContext};
    use sui::vec_set::{Self, VecSet};

    friend sui_swap_core::nft_service;

    const ENotAdmin: u64 = 100;
    const ENotAllowedImpl: u64 = 101;
    const EInvalidPublisher: u64 = 102;

    struct NFT_SERVICE_CONFIG has drop {}

    struct NftServiceConfig has key, store {
        id: UID,
        impl_allowlist: VecSet<TypeName>,
    }

    struct NftServiceConfigCap has key, store {
        id: UID,
        for: ID
    }

    fun init(otw: NFT_SERVICE_CONFIG, ctx: &mut TxContext) {
        let publisher = package::claim(otw, ctx);
        create_config(&publisher, ctx);
        transfer::public_transfer(publisher, sender(ctx));
    }

    #[lint_allow(self_transfer)]
    entry fun create_config(publisher: &Publisher, ctx: &mut TxContext) {
        assert!(package::from_package<NFT_SERVICE_CONFIG>(publisher), EInvalidPublisher);
        let config = NftServiceConfig {
            id: object::new(ctx),
            impl_allowlist: vec_set::empty(),
        };
        let cap = NftServiceConfigCap {
            id: object::new(ctx),
            for: object::id(&config),
        };
        sui::transfer::transfer(cap, tx_context::sender(ctx));
        sui::transfer::share_object(config);
    }

    public fun add_allowed_impl<WT>(config: &mut NftServiceConfig, cap: &NftServiceConfigCap) {
        assert!(has_access(config, cap), ENotAdmin);
        let type_name = type_name::get<WT>();
        if (!vec_set::contains(&config.impl_allowlist, &type_name)) {
            vec_set::insert(&mut config.impl_allowlist, type_name);
        };
    }

    public fun remove_allowed_impl<WT>(config: &mut NftServiceConfig, cap: &NftServiceConfigCap) {
        assert!(has_access(config, cap), ENotAdmin);
        let type_name = type_name::get<WT>();
        if (vec_set::contains(&config.impl_allowlist, &type_name)) {
            vec_set::remove(&mut config.impl_allowlist, &type_name);
        };
    }

    public(friend) fun assert_allowlisted<WT: drop>(config: &NftServiceConfig, _impl_witness: WT) {
        assert!(vec_set::contains(&config.impl_allowlist, &type_name::get<WT>()), ENotAllowedImpl);
    }

    /// Check whether the config-cap matches the config.
    public fun has_access(config: &mut NftServiceConfig, cap: &NftServiceConfigCap): bool {
        object::id(config) == cap.for
    }
}
