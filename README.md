# Flex: An NFT Assets Exchange on Sui

This repository contains on-chain contracts as well as off-chain service (indexer) of Flex.

## Requirements

### Sell Pool / Buy Pool / Trade Pool

There is nothing special about trade pool, other than the fact that it features both a sell pool and a buy pool.

Tip: In our Move contract code, we use a `struct` called `TradePool` to represent "trade pool" (for bidirectional trades),
as well as the "sell pool" and the "buy pool".
The different types of pools are distinguished by the `pool_type` field in this struct.

You can think of trade pool as the base type of sell pool and buy pool - although the latter two don't have corresponding Move `struct`s.
In other words, sell pools and buy pools can be thought of as specialized trade pools with limited functionality.


#### Sell Pool

A sell pool allows users to buy NFT assets from the pool with FT assets (SUI or any coins that comply with the Sui Coin standard).

The "Sell Pool" entity has some similarity to `TokenPair`. Properties of Sell Pool:

* It has `ExchangeRateNumerator` and `ExchangeRateDenominator` properties, 
    which represent the "exchange rate" of NFT (X token) to Y token. (Similar to `fixed-exchange-rate` branch version.)
* Implement a linear price curve (exponential curve will be implemented later). 
    To do this, the pool needs a couple of properties: 
    for every `PriceDeltaX_Amount` sold, the price of X token increases by `PriceDeltaNumerator` / `PriceDeltaDenominator`.
* Anyone can create a Sell Pool.
* The owner of the pool can modify the NFT price related settings of the pool; 
    can add X token (NFT); can take out X token; can take out Y token (FT) reserve.
    The owner of the pool can destroy the pool.
* Methods of sell pool for general users include `BuyX`, i.e. "Swap-Y-For-X".

[Documentation to be improved.]


#### Buy Pool

[Documentation to be improved.]

#### Trade Pool

[Documentation to be improved.]

### Token Pair

This `nft` branch currently also implements a NFT/FT `TokenPair` that supports the AMM model.

One problem with using the AMM model to support NFT/FT swap is that the indivisibility of NFTs results in the "last NFT" being unsellable.
Because of the fixed-product formula of AMM, the amount of token Y needed to buy up token X is infinite.

When having Sell Pool, the owner of the token pair can take out the last NFT in the `TokenPair` by removing all liquidity and create a Sell Pool to sell it.
Actually, a "Token Pair" plus a simple "Sell Pool" (for selling NFTs), it can already be said to be a complete MVP (Minimum Viable Product) of NFT exchange Dapp.


## Development Prerequisites

We develop it using the [dddappp](https://www.dddappp.org) low-code tool.

Currently, the dddappp low-code tool is published as a Docker image for developers to experience.

So before getting started, you need to:

* Install [Sui](https://docs.sui.io/build/install).

* Install [Docker](https://docs.docker.com/engine/install/).

* (Optional) Install MySQL database server if you want to test the off-chain service. The off-chain service generated by the tool currently use MySQL by default.

* (Optional) Install JDK and Maven if you want to test the off-chain service. The off-chain services generated by the tool currently use Java.

If you have already installed Docker, you can use Docker to run a MySQL database service. For example:

```shell
sudo docker run -p 3306:3306 --name mysql \
-v ~/docker/mysql/conf:/etc/mysql \
-v ~/docker/mysql/logs:/var/log/mysql \
-v ~/docker/mysql/data:/var/lib/mysql \
-e MYSQL_ROOT_PASSWORD=123456 \
-d mysql:5.7
```

## About Programming

### Write DDDML model file

In the `dddml` directory in the root of the repository, create a DDDML file like [this](./dddml/swap.yaml).

> **Tip**
>
> About DDDML, here is an introductory article: ["Introducing DDDML: The Key to Low-Code Development for Decentralized Applications"](https://github.com/wubuku/Dapp-LCDP-Demo/blob/main/IntroducingDDDML.md).

There is one thing worth noting: why do we use property names like `X_Amount` in DDDML files - that is,
cases where one of the components of the property name is a "single letter".

The off-chain service code we generated was written in Java;
and Java Bean specification, in a way, 
does not handle correctly when converting various naming styles (e.g. `PascalCase`, `camelCase`, `snake_case`, etc.) 
for property names like `XAmount` is required.
To get around this problem, we decided to use property names like `X_Amount` instead of `XAmount`.

### Run dddappp project creation tool

#### Update dddappp Docker image

Since the dddappp v0.0.1 image is updated frequently, you may be required to manually delete the image and pull it again before `docker run`.

```shell
# If you have already run it, you may need to Clean Up Exited Docker Containers first
docker rm $(docker ps -aq --filter "ancestor=wubuku/dddappp:0.0.1")
# remove the image
docker image rm wubuku/dddappp:0.0.1
# pull the image
docker pull wubuku/dddappp:0.0.1
```

---

In repository root directory, run:

```shell
docker run \
-v .:/myapp \
wubuku/dddappp:0.0.1 \
--dddmlDirectoryPath /myapp/dddml \
--boundedContextName Test.SuiSwapExample \
--suiMoveProjectDirectoryPath /myapp/sui-contracts/core \
--boundedContextSuiPackageName sui_swap_core \
--boundedContextJavaPackageName org.test.suiswapexample \
--javaProjectsDirectoryPath /myapp/sui-java-service \
--javaProjectNamePrefix suiswapexample \
--pomGroupId test.suiswapexample
```

The command parameters above are straightforward:

* This line `-v .:/myapp \` indicates mounting the local current directory into the `/myapp` directory inside the container.
* `dddmlDirectoryPath` is the directory where the DDDML model files are located. It should be a directory path that can be read in the container.
* Understand the value of the `boundedContextName` parameter as the name of the application you want to develop. When the name has multiple parts, separate them with dots and use the PascalCase naming convention for each part. Bounded-context is a term in Domain-driven design (DDD) that refers to a specific problem domain scope that contains specific business boundaries, constraints, and language. If you cannot understand this concept for the time being, it is not a big deal.
* `boundedContextJavaPackageName` is the Java package name of the off-chain service. According to Java naming conventions, it should be all lowercase and the parts should be separated by dots.
* `boundedContextSuiPackageName` is the package name of the on-chain Sui contracts. According to the Sui development convention, it should be named in snake_case style with all lowercase letters.
* `javaProjectsDirectoryPath` is the directory path where the off-chain service code is placed. The off-chain service consists of multiple modules (projects). It should be a readable and writable directory path in the container.
* `javaProjectNamePrefix` is the name prefix of each module of the off-chain service. It is recommended to use an all-lowercase name.
* `pomGroupId` is the GroupId of the off-chain service. We use Maven as the project management tool for off-chain service. It should be all lowercase and the parts should be separated by dots.
* `suiMoveProjectDirectoryPath` is the directory path where the on-chain Sui contract code is placed. It should be a readable and writable directory path in the container.

After the above command is successfully executed, two directories `sui-java-service` and `sui-contracts/core` should be added to the local current directory.


### Implementing business logic

For the on-chain contract part, the tool creates a lot of Move code for us, 
and generally, we should not modify any source code files that start with the comment `// <autogenerated>`.

The work of implementing the business logic code is mainly done in those files with the suffix `_logic.move` in the directory `sui-contracts/core/sources`.
These files contain the scaffolding code of functions that implement business logic,
namely the signature part of the functions.
You just need to fill in the implementation part of the functions.


[Documentation to be improved.]

---

In [the model file](./dddml/swap.yaml), we defined some methods which use `Balance`, a resource type, as type of parameters or return values.
This makes these methods very combinable - as a developer of Move, a "resource-oriented programming" language,
you will already know this.

However, it's not easy to call them directly from clients.
So, we added this file [token_pair_service.move](sui-contracts/core/sources/token_pair_service.move).
In this file, some entry functions are provided to facilitate clients to use the corresponding features directly.

That's the whole programming routine, isn't it simple?

## Test Application

In the example commands below for test, 
we have used the following placeholders, please note that they need to be replaced with actual values:

* `{UTILS_PACKAGE_ID}`: The package ID of the `utils` project.
* `{CORE_PACKAGE_ID}`: The package ID of the `core` project.
* `{NFT_SERVICE_IMPL_PACKAGE_ID}`: The package ID of the `nft-service-impl` project.
* `{DI_PACKAGE_ID}`: The package ID of the `di` project.
* `{EXCHANGE_OBJECT_ID}`: The object ID of the `Exchange` object.
* `{NFT_SERVICE_CONFIG_OBJECT_ID}`: The object ID of the `NftServiceConfig` object.
* `{NFT_SERVICE_CONFIG_CAP_OBJECT_ID}`: The object ID of the `NftServiceConfigCap` object.

These placeholders also appear in the example output below, indicating the position of the actual value as it appears in the output.

For the following tests, we default to on testnet.

On the Sui testnet, we deployed as well as set up a set of test contracts with the values of these placeholders:

| Placeholder                             | Value                                                              |
|-----------------------------------------|--------------------------------------------------------------------|
| UTILS_PACKAGE_ID                        | 0xf08c2f0fce586a3d0b6e4964b31a4e8b46e060fe17bb591b6c8deb5514f67c22 |
| CORE_PACKAGE_ID                         | 0x93d594cf0e132c68fabce857b5abd89cdb7b34e27dcbd5a3c0dc809a0ffb3fea |
| NFT_SERVICE_IMPL_PACKAGE_ID             | 0x6485d131e5a2a30c7b606fcb71c1b3c828f00ae5e5e4298269cc9e7287fe0223 |
| NFT_SERVICE_IMPL_PACKAGE_ID_2           | 0x2ec32d6b9280d0c26280310e1367a5db3f5aa9bd8f3d7112170518522fead632 |
| DI_PACKAGE_ID                           | 0xe8ab46a6a9e24ee824a819f6e2aa68cc4bb4f6981057495c9919755ed74f7099 |
| DI_PACKAGE_ID_2                         | 0x5780d0992aa082a83f52acaf82d44ec52c21373f7709d556f73774447f6524a0 |
| EXCHANGE_OBJECT_ID                      | 0xdb548141e56f50ade96f9a8c16070f79c89e71408c43f8a1636ad82f958de45b |
| NFT_SERVICE_CONFIG_OBJECT_ID            | 0xb60641282c6d3f96fd6942c093f0ce2c8cf6c54a09fd8834a68777de73b03b36 |
| NFT_SERVICE_CONFIG_CAP_OBJECT_ID        | 0xdff5d4f408cef1ea52e43ac39b361485c6f2489970c2864588a261b511f96c06 |
| PUBLISH_CORE_PROJECT_TRANSACTION_DIGEST | 9JE4EGWDNgFpw93Yt3WWUPaiytbkncUcTuSogzh6THZN                       |


Note that when testing with the Sui CLI, switch the environment to testnet first:

```shell
sui client switch --env testnet
```

### Some preparations might be needed

#### Prepare some SUI coins

View the SUI coin objects in the current Sui CLI account:

```shell
sui client gas
```

If you have only one SUI coin object in your account, you can transfer some SUI to your account first to split this SUI coin object.
In the following test, we need to use a SUI coin object to add liquidity in addition to a SUI coin object to pay gas fee:

```shell
sui client pay-sui --input-coins 0x79e6fd15db671bdf426166a494f15845353701c742febb66e88fb61a4981a5d1 --amounts 1000000000 \
--recipients 0xfc50aa2363f3b3c5d80631cae512ec51a8ba94080500a981f4ae1a2ce4d201c2 --gas-budget 30000000
```

#### Mint some Movescription tokens

We use Movescription token `MOVE` as test NFT. Movescription is a community-driven inscription protocol on Move.

We have deployed a movescription test contract on testnet with package ID: `0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff`.

Object ID of the `TickRecord` used to mint the `MOVE` inscription: `0x34fccc1a953d02f3a7ddbd546e7982aff89c6989c8181d34e788bd855cb6ff64`.

Mint some test inscriptions (please allow one minute between each mint),
Note that the third parameter, `0x44e677e7fbfebef80d484eca63e350a1e8d9d5da4ab5a1e757d7e22a2d0a7b2c` 
in the example below should be changed to the ID of one of your owned SUI Coin objects.

```shell
sui client call --package 0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff --module movescription --function mint --args 0x34fccc1a953d02f3a7ddbd546e7982aff89c6989c8181d34e788bd855cb6ff64 \"MOVE\" 0x44e677e7fbfebef80d484eca63e350a1e8d9d5da4ab5a1e757d7e22a2d0a7b2c \"0x6\" --gas-budget 19000000
```

Maybe you want to quickly make some more inscription objects for testing, then, you can split an inscription object like this:

```shell
sui client call --package 0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff --module movescription --function split --args  0x221fe24766ee163ca1fcee68ffb894a189815f5d324cd7e5db2ea505dbb46b9b '"1000"' --gas-budget 19000000
```

#### Mint Some test NFTs

For testing, we can deploy this contract: `. /sui-contracts/example_tokens/sources/equipment.move`.

On testnet we have deployed this contract at address (package ID): `0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c`.

We can then mint some NFTs for testing like this:

```shell
sui client call --package 0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c --module equipment --function mint --args '1' --gas-budget 11000000
sui client call --package 0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c --module equipment --function mint --args '2' --gas-budget 11000000
sui client call --package 0x8b697f60efef437887f3c1c80879091a7e60f9880e4a41d745b96f0fb520691c --module equipment --function mint --args '3' --gas-budget 11000000
```

> **Hint**
> 
> On testnet, we also deployed the contract at another address (package ID): `0x507d2aacb7425085612e0d56131a57362729779bf3510c286b98568479314920`.
> The publishing transaction digest: `44kiFkx9im8G4RNs5ZaBpB1KN9LL7tRLHZXWRZ8FvKGm`.
> The package ID of the corresponding "nft-service-impl" contract for this contract is: `0x2ec32d6b9280d0c26280310e1367a5db3f5aa9bd8f3d7112170518522fead632`.
> The package ID of the corresponding DI contract is: `0x5780d0992aa082a83f52acaf82d44ec52c21373f7709d556f73774447f6524a0`.


### Deploy contracts

#### Deploy utils project

Execute the following command in the directory `sui-contracts/utils` to publish the `utils` project on chain:

```shell
sui client publish --gas-budget 200000000 --skip-fetch-latest-git-deps --skip-dependency-verification
```

Take note of the deployed `utils` package ID in the output of the command:

```text
│ Published Objects:                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            │
│  ┌──                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          │
│  │ PackageID: {UTILS_PACKAGE_ID}
```

Modify `sui-contracts/utils/Move.toml`:

```toml
[package]
published-at = "{UTILS_PACKAGE_ID}"

[addresses]
sui_swap_core = "{UTILS_PACKAGE_ID}
```

#### Deploy core project

Execute the following command in the directory `sui-contracts/core` to publish the `core` project on chain:

```shell
sui client publish --gas-budget 900000000 --skip-fetch-latest-git-deps --skip-dependency-verification
```

If the command is executed successfully, the transaction digest of this publication will be output. For example:

```text
Transaction Digest: {PUBLISH_CORE_PROJECT_TRANSACTION_DIGEST}
```

Take note of this transaction digest. When setting up the off-chain service, we will need it.

And record the package ID of the `core` project and a number of objects created in the output of the command, 
such as the object ID of the `NftServiceConfig` object, etc.
We use the following object IDs for the next tests:

```text
│ Published Objects:
│  ┌──
│  │ PackageID: {CORE_PACKAGE_ID}

│ Created Objects:
│  ┌──

│  │ ObjectID: {NFT_SERVICE_CONFIG_OBJECT_ID}
│  │ ObjectType: {CORE_PACKAGE_ID}::nft_service_config::NftServiceConfig

│  │ ObjectID: {NFT_SERVICE_CONFIG_CAP_OBJECT_ID}
│  │ ObjectType: {CORE_PACKAGE_ID}::nft_service_config::NftServiceConfigCap

│  │ ObjectID: {EXCHANGE_OBJECT_ID}
│  │ ObjectType: {CORE_PACKAGE_ID}::exchange::Exchange
```

Modify `sui-contracts/core/Move.toml`:

```toml
[package]
published-at = "{CORE_PACKAGE_ID}"

[addresses]
sui_swap_core = "{CORE_PACKAGE_ID}"
```

#### Contract upgrade records

~~Note that the current "core" project package ID of the latest version on testnet is `{CORE_PACKAGE_ID}`.~~

The new version fixes some bugs.
If you need to call functions in the "core" package, use the latest version if possible.

> **Hint**
> 
> When a contract is upgraded, The new package ID is not the same as the address of the object it can operate on.
> It's possible that front-end programming will need to be aware of this, 
> such as when doing some configuration things for the application.
> About upgrade of Sui contract, please refer to the [Sui documentation](https://docs.sui.io/concepts/sui-move-concepts/packages/upgrade).


#### Deploy "nft-service-impl" project

Under the directory `sui-contracts/nft-service-impl`, publish the contract:

```shell
sui client publish --gas-budget 300000000 --skip-fetch-latest-git-deps --skip-dependency-verification
```

Record the following information:

```text
Transaction Digest: {PUBLISH_NFT_SERVICE_IMPL_PROJECT_TRANSACTION_DIGEST}

│ Published Objects:                                                                               │
│  ┌──                                                                                             │
│  │ PackageID: {NFT_SERVICE_IMPL_PACKAGE_ID}                 │
```

Modify the file `/sui-contracts/nft-service-impl/Move.toml`:

```text
[package]
published-at = "{NFT_SERVICE_IMPL_PACKAGE_ID}"

[addresses]
nft_service_impl = "{NFT_SERVICE_IMPL_PACKAGE_ID}"
```

#### Deploy "di" project

In theory, the `di` projects are not absolutely necessary to deploy.
We can consider utilizing Sui's [PTB](https://docs.sui.io/concepts/transactions/prog-txn-blocks) feature
on the front end to call the `core` project contract and the `nft-service-impl` project contract directly
to accomplish the functionality shown in the test below.

---

Execute the following command in the directory `sui-contracts/di` to publish the `di` project on chain:

```shell
sui client publish --gas-budget 300000000 --skip-fetch-latest-git-deps --skip-dependency-verification
```

Record the following information:

```text
Transaction Digest: {PUBLISH_DI_PROJECT_TRANSACTION_DIGEST}

│ Published Objects:
│  ┌──
│  │ PackageID: {DI_PACKAGE_ID}
```

#### Configure dependency injection allowlist

Only the publisher of the `core` project package can do this. Execute the following:

```shell
sui client call --function add_allowed_impl --module nft_service_config --package {CORE_PACKAGE_ID} \
--type-args '{NFT_SERVICE_IMPL_PACKAGE_ID}::movescription_service_impl::MovescriptionServiceImpl' \
--args {NFT_SERVICE_CONFIG_OBJECT_ID} {NFT_SERVICE_CONFIG_CAP_OBJECT_ID} \
--gas-budget 300000000

sui client call --function add_allowed_impl --module nft_service_config --package {CORE_PACKAGE_ID} \
--type-args '{NFT_SERVICE_IMPL_PACKAGE_ID}::test_equipment_service_impl::TestEquipmentServiceImpl' \
--args {NFT_SERVICE_CONFIG_OBJECT_ID} {NFT_SERVICE_CONFIG_CAP_OBJECT_ID} \
--gas-budget 300000000
```


### Sell Pool tests

Sell pool properties related to price settings:

* `PriceCurveType`: Can be `0` (linear) or `1` (exponential). The difference between the two is that 
    in the former case, the X token price increases are based on the start price, which is a fixed value, 
    in the latter case on the current price, which is updated every time a certain amount of X is sold.
* `StartExchangeRateNumerator`: The start X price against Y (exchange rate numerator of X to Y) is `StartExchangeRateNumerator` / `ExchangeRateDenominator`.
* `ExchangeRateNumerator`: The current X price is `ExchangeRateNumerator` / `ExchangeRateDenominator`.
* `ExchangeRateDenominator`. For example, if the start price of X against Y is `12.3456` and the current price is `98.7654`, 
    then the `StartExchangeRateNumerator` can be set to `123456`, 
    and the `ExchangeRateNumerator` can be set to `987654`,
    and the `ExchangeRateDenominator` can be set to `10000`. 
* `PriceDeltaX_Amount`: For every `PriceDeltaX_Amount` sold, the price of X token increases by `PriceDeltaNumerator` / `PriceDeltaDenominator`.
* `PriceDeltaNumerator`.
* `PriceDeltaDenominator`. For example, if the price increases by 10% for every 200 amount of X sold, then `PriceDeltaX_Amount` can be set to `200`, 
    and `PriceDeltaNumerator` can be set to `10`, and `PriceDeltaDenominator` can be set to `100`.


#### Initialize sell pool

Note the arguments required by the function, which are assumed by the following test command:

* `_nft_service_config: &NftServiceConfig`: `{NFT_SERVICE_CONFIG_OBJECT_ID}`.
* `exchange: &mut Exchange`: Assuming the ID of the `Exchange` object is `{EXCHANGE_OBJECT_ID}`.
* `x: Movescription`: The ID of the `Movescription` object is `0x265d67ce5eea98b8a482c846537b0e0cb84b911d6b2d34cc78b3c81fc11d73d0`.
* `exchange_rate_numerator: u64`: We are going to set exchange rate of X to Y as 11110/100.
* `exchange_rate_denominator: u64`.
* `price_curve_type: u8`: We are going to use a linear price curve (0).
* `price_delta_x_amount: u64`. Every 10 (amount) X token sold, the price of X token will increase by 10%.
* `price_delta_numerator: u64`: 10.
* `price_delta_denominator: u64`: 100.

So, the command that needs to be executed is similar to the following:

```shell
sui client call --package {DI_PACKAGE_ID} --module movescription_sell_pool_service --function initialize_sell_pool \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'{EXCHANGE_OBJECT_ID}' \
'0x265d67ce5eea98b8a482c846537b0e0cb84b911d6b2d34cc78b3c81fc11d73d0' \
'"11110"' \
'"100"' \
'0' \
'"10"' \
'"10"' \
'"100"' \
--gas-budget 100000000
```

Note the output IDs of `TradePool` object (**it's actually a sell pool**) and `LiquidityToken` object:

```text
│  │ ObjectID: 0x0f765d3333b23314721ca5f434f1a3c3d2274986538b9989b3ca43f722647630
│  │ Sender: 0x...
│  │ Owner: Shared
│  │ ObjectType: 0x...::trade_pool::TradePool<...>

│  │ ObjectID: 0x3979a8a594b8dc192c164b48a8e9f428e213d31f41a0e2ee4c50a0c76392f38c                    │
│  │ Sender: 0xfc50aa2363f3b3c5d80631cae512ec51a8ba94080500a981f4ae1a2ce4d201c2                      │
│  │ Owner: Account Address ( 0xfc50aa2363f3b3c5d80631cae512ec51a8ba94080500a981f4ae1a2ce4d201c2 )   │
│  │ ObjectType: 0x...::liquidity_token::LiquidityToken<...>                                         │
```

#### Owner add X token to sell pool

The function parameters:

* `_nft_service_config: &NftServiceConfig`: `{NFT_SERVICE_CONFIG_OBJECT_ID}`.
* `pool: &mut TradePool<Movescription, Y>`: The ID of sell pool or trade pool object.
* `liquidity_token: &LiquidityToken<Movescription, Y>`.
* `x: Movescription`: The ID of the `Movescription` object is `0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9`.

Execute the following command:

```shell
sui client call --package {DI_PACKAGE_ID} --module movescription_sell_pool_service --function add_x_token \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'0x0f765d3333b23314721ca5f434f1a3c3d2274986538b9989b3ca43f722647630' \
'0x3979a8a594b8dc192c164b48a8e9f428e213d31f41a0e2ee4c50a0c76392f38c' \
'0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9' \
--gas-budget 100000000
```

#### Buy X token from sell pool

The function parameters:

* `pool: &mut TradePool<X, Y>`: The ID of sell pool or trade pool object.
* `y_coin: Coin<Y>`: The SUI Coin object you own.
* `y_amount: u64`: The amount of SUI coin you would like to pay.
* `x_id: ID`: Assumes the ID of the NFT object you want to get is `0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9`.

So, execute the following command:

```shell
sui client call --package {CORE_PACKAGE_ID} --module sell_pool_service --function buy_x \
--type-args '0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff::movescription::Movescription' '0x2::sui::SUI' \
--args '0x0f765d3333b23314721ca5f434f1a3c3d2274986538b9989b3ca43f722647630' \
'0x2d5aa8072b01f29fe074d4d0be89a33ebc4c4d63b6fc3bd0b611fde655a703e0' \
'"10000000"' \
'0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9' \
--gas-budget 100000000
```

~~Note the package ID above, we are using a newer version than `{CORE_PACKAGE_ID}`.~~

#### Owner remove X token from sell pool

* `pool: &mut TradePool<X, Y>`: The ID of pool object.
* `liquidity_token: &LiquidityToken<X, Y>`.
* `x_id: ID`: Assumes the ID of the NFT object you want to remove is `0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9`.

Execute the following command:

```shell
sui client call --package {CORE_PACKAGE_ID} --module trade_pool_service --function remove_x_token \
--type-args '0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff::movescription::Movescription' '0x2::sui::SUI' \
--args '0x0f765d3333b23314721ca5f434f1a3c3d2274986538b9989b3ca43f722647630' \
'0x3979a8a594b8dc192c164b48a8e9f428e213d31f41a0e2ee4c50a0c76392f38c' \
'0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9' \
--gas-budget 100000000
```

#### Owner withdraw Y reserve from sell pool

The function parameters:

* `pool: &mut TradePool<X, Y>`.
* `liquidity_token: &LiquidityToken<X, Y>`.
* `y_amount: u64`.
* `y_coin: &mut Coin<Y>`.

Execute the following command:

```shell
sui client call --package {CORE_PACKAGE_ID} --module trade_pool_service --function withdraw_y_reserve \
--type-args '0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff::movescription::Movescription' '0x2::sui::SUI' \
--args '0x0f765d3333b23314721ca5f434f1a3c3d2274986538b9989b3ca43f722647630' \
'0x3979a8a594b8dc192c164b48a8e9f428e213d31f41a0e2ee4c50a0c76392f38c' \
'"10000000"' \
'0x2d5aa8072b01f29fe074d4d0be89a33ebc4c4d63b6fc3bd0b611fde655a703e0' \
--gas-budget 100000000
```

#### Owner update exchange rate

The function parameters:

* `pool: &mut TradePool<X, Y>`.
* `liquidity_token: &LiquidityToken<X, Y>`.
* `start_exchange_rate_numerator: u64`: We can reset the start exchange rate. Linear price curve will use this to calculate "delta".
* `exchange_rate_numerator: u64`: We are going to set current exchange rate of X to Y as 11112/100.
* `exchange_rate_denominator: u64`: 100.
* `price_delta_x_amount: u64`. Every 10 (amount) X token sold, the price of X token will increase by 11%.
* `price_delta_numerator: u64`: 11.
* `price_delta_denominator: u64`: 100.

Execute the following command:

```shell
sui client call --package {CORE_PACKAGE_ID} --module trade_pool_aggregate --function update_exchange_rate \
--type-args '0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff::movescription::Movescription' '0x2::sui::SUI' \
--args '0x0f765d3333b23314721ca5f434f1a3c3d2274986538b9989b3ca43f722647630' \
'0x3979a8a594b8dc192c164b48a8e9f428e213d31f41a0e2ee4c50a0c76392f38c' \
'"11112"' \
'"11112"' \
'"100"' \
'"11"' \
'"11"' \
'"100"' \
--gas-budget 100000000
```

~~Note the package ID above, we are using a newer version than `{CORE_PACKAGE_ID}`.~~

### Buy Pool tests

#### Initialize buy pool


Note the arguments required by the function, which are assumed by the following test command:

* `exchange: &mut Exchange`: Assuming the ID of the `Exchange` object is `{EXCHANGE_OBJECT_ID}`.
* `y_coin: Coin<Y>`: The ID of SUI coin object.
* `y_amount: u64`: The initial amount deposited into the pool.
* `exchange_rate_numerator: u64`: We are going to set exchange rate of X to Y as 11110/100.
* `exchange_rate_denominator: u64`.
* `price_curve_type: u8`: We are going to use a linear price curve (0).
* `price_delta_x_amount: u64`. Every 500 (amount) X token sold, the price of X token will increase by 10%.
* `price_delta_numerator: u64`: 10.
* `price_delta_denominator: u64`: 100.

So, the command that needs to be executed is similar to the following:

```shell
sui client call --package {CORE_PACKAGE_ID} --module buy_pool_service --function initialize_buy_pool \
--type-args '0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff::movescription::Movescription' '0x2::sui::SUI' \
--args \
'{EXCHANGE_OBJECT_ID}' \
'0x4f2a2f3f3b564276d6ef103ade6f321d7a857b28236d8e0d6a628af416bb332a' \
'"200000000"' \
'"11110"' \
'"100"' \
'0' \
'"500"' \
'"10"' \
'"100"' \
--gas-budget 100000000
```

Note the output IDs of `TradePool` object (**it's actually a buy pool**) and `LiquidityToken` object:

```text
│  │ ObjectID: 0x5c87d86c0ebfad6d969c16e6acedf2f7413d7fab2e263cca2bf35474f55c6914
│  │ Sender: 0x...
│  │ Owner: Shared
│  │ ObjectType: 0x...::trade_pool::TradePool<...>

│  │ ObjectID: 0xaba9f8a4b6942318fd78dc7d7e2c904bcea5d88f8458a9979e770ff48c32b741                    │
│  │ Sender: 0xfc50aa2363f3b3c5d80631cae512ec51a8ba94080500a981f4ae1a2ce4d201c2                      │
│  │ Owner: Account Address ( 0xfc50aa2363f3b3c5d80631cae512ec51a8ba94080500a981f4ae1a2ce4d201c2 )   │
│  │ ObjectType: 0x...::liquidity_token::LiquidityToken<...>                                         │
```

#### Deposit Y reserve to buy pool

The function parameters:

* `pool: &mut TradePool<X, Y>`: The ID of pool object.
* `liquidity_token: &LiquidityToken<X, Y>`.
* `y_coin: Coin<Y>`: The SUI Coin object you own.
* `y_amount: u64`: The amount of SUI coin you would like to deposit.

Execute the following command:

```shell
sui client call --package {CORE_PACKAGE_ID} --module trade_pool_service --function deposit_y_reserve \
--type-args '0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff::movescription::Movescription' '0x2::sui::SUI' \
--args '0x0f765d3333b23314721ca5f434f1a3c3d2274986538b9989b3ca43f722647630' \
'0x3979a8a594b8dc192c164b48a8e9f428e213d31f41a0e2ee4c50a0c76392f38c' \
'0x2d5aa8072b01f29fe074d4d0be89a33ebc4c4d63b6fc3bd0b611fde655a703e0' \
'"1000000"' \
--gas-budget 100000000
```

#### Sell X token to buy pool

The function parameters:

* `_nft_service_config: &NftServiceConfig`.
* `pool: &mut TradePool<Movescription, Y>`: The ID of buy pool or trade pool object.
* `x: Movescription`: The ID of the `Movescription` object. Assume it's `0x46aa287745397cfc88fc007b53ed9142c22433ac370d4a761cc572fd85602c0c`.
* `y_coin: &mut Coin<Y>`: The SUI Coin object you own to accept the balance.
* `expected_y_amount_out: u64`: The minimum acceptable output amount is expected.

Execute the following command:

```shell
sui client call --package {DI_PACKAGE_ID} --module movescription_buy_pool_service --function sell_x \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'0x5c87d86c0ebfad6d969c16e6acedf2f7413d7fab2e263cca2bf35474f55c6914' \
'0x46aa287745397cfc88fc007b53ed9142c22433ac370d4a761cc572fd85602c0c' \
'0x4f2a2f3f3b564276d6ef103ade6f321d7a857b28236d8e0d6a628af416bb332a' \
'"100"' \
--gas-budget 100000000
```

#### Owner remove X token from buy pool

Same as "Owner remove X token from sell pool". No repetition here.

#### Owner withdraw Y reserve from buy pool

Same as "Owner withdraw Y reserve from sell pool".

#### Owner update exchange rate

Same as "Owner update exchange rate" of sell pool.

### Trade Pool tests

#### Initialize Movescription trade pool

The function parameters:

* `_nft_service_config: &NftServiceConfig`.
* `exchange: &mut Exchange`: Assuming the ID of the `Exchange` object is `{EXCHANGE_OBJECT_ID}`.
* `x: Movescription`: The ID of the `Movescription` object. Assume it's `0xc9d176d57cd8b51ca8cfed99cc22ecd10b013cec55a2850c96c7cf8c72cde3dc`.
* `y_coin: Coin<Y>`: The ID of SUI coin object. Assume it's `0xfc63af4bf36bf4b4ba18e6dc7a9936942ba8e192f77766fcc3b67f20dd9a541e`.
* `y_amount: u64`: The initial amount deposited into the pool.
* `exchange_rate_numerator: u64`: We are going to set exchange rate of X to Y as 11110/100.
* `exchange_rate_denominator: u64`.
* `price_curve_type: u8`: We are going to use an exponential price curve (1).
* `price_delta_x_amount: u64`. Every 500 (amount) X token sold, the price of X token will increase by 10%.
* `price_delta_numerator: u64`: 10.
* `price_delta_denominator: u64`: 100.

So, the command that needs to be executed is similar to the following:

```shell
sui client call --package {DI_PACKAGE_ID} --module movescription_trade_pool_service --function initialize_trade_pool \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'{EXCHANGE_OBJECT_ID}' \
'0xc9d176d57cd8b51ca8cfed99cc22ecd10b013cec55a2850c96c7cf8c72cde3dc' \
'0xfc63af4bf36bf4b4ba18e6dc7a9936942ba8e192f77766fcc3b67f20dd9a541e' \
'"200000000"' \
'"11110"' \
'"100"' \
'1' \
'"500"' \
'"10"' \
'"100"' \
--gas-budget 100000000
```

Note the output IDs of `TradePool` object and `LiquidityToken` object:

```text
│  │ ObjectID: 0x6367c30fc72767b43c0be0e3c50184a6b1302c03c8fa95c2236ee6477e55a3ef
│  │ Sender: 0x...
│  │ Owner: Shared
│  │ ObjectType: 0x...::trade_pool::TradePool<...>

│  │ ObjectID: 0x31604eb60c53ec66ac66937496fdc98715bd0551a374807ce51c63d614c3fb92
│  │ Sender: 0x...
│  │ Owner: Account Address ...
│  │ ObjectType: 0x...::liquidity_token::LiquidityToken<...>
```

#### Initialize test NFT trade pool

The function parameters:

* `_nft_service_config: &NftServiceConfig`.
* `exchange: &mut Exchange`: Assuming the ID of the `Exchange` object is `{EXCHANGE_OBJECT_ID}`.
* `x: Equipment`: The ID of the test `Equipment` object. Assume it's `0xbbdd0d9ff7307aa7a5af62219c45786070786ca1d805c14bb416235824cd3e3f`.
* `y_coin: Coin<Y>`: The ID of SUI coin object. Assume it's `0x09d2790f76f11f12898e4049c2c72aaeaf32a0341797d797d038dae836457433`.
* `y_amount: u64`: The initial amount deposited into the pool.
* `exchange_rate_numerator: u64`: We are going to set exchange rate of X to Y as 11110/100.
* `exchange_rate_denominator: u64`.
* `price_curve_type: u8`: We are going to use a linear price curve (1).
* `price_delta_x_amount: u64`. Every 1 (amount) X token sold, the price of X token will increase by 6%.
* `price_delta_numerator: u64`: 6.
* `price_delta_denominator: u64`: 100.

So, the command that needs to be executed is similar to the following:

```shell
sui client call --package {DI_PACKAGE_ID} --module test_equipment_trade_pool_service --function initialize_trade_pool \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'{EXCHANGE_OBJECT_ID}' \
'0xbbdd0d9ff7307aa7a5af62219c45786070786ca1d805c14bb416235824cd3e3f' \
'0x09d2790f76f11f12898e4049c2c72aaeaf32a0341797d797d038dae836457433' \
'"100000000"' \
'"11110"' \
'"100"' \
'0' \
'"1"' \
'"6"' \
'"100"' \
--gas-budget 100000000
```

Note the output IDs of `TradePool` object and `LiquidityToken` object:

```text
│  │ ObjectID: 0xe564b59c43af59f002feb538851fe86fc85ad07fa2048320ad0c876f9ff9210a
│  │ Sender: 0x...
│  │ Owner: Shared
│  │ ObjectType: 0x...::trade_pool::TradePool<...::equipment::Equipment, 0x2::sui::SUI>

│  │ ObjectID: 0x21c448da7d23ec11780dbdfda720a509d450ac9f590486134f63ce7440e55b69
│  │ Sender: 0x...
│  │ Owner: Account Address ...
│  │ ObjectType: 0x...::liquidity_token::LiquidityToken<...::equipment::Equipment, 0x2::sui::SU>
```

#### Initialize test NFT trade pool with empty X reserve

The function parameters is the same as "initialize_buy_pool".

We assume that the SUI coin object is `0x42ce68efec70dc482cafb4eb6f6e759074ab8397202cb8002f9fb33130951758`, execute the command:

```shell
sui client call --package {CORE_PACKAGE_ID} --module trade_pool_service --function initialize_trade_pool_with_empty_x_reserve \
--type-args '0x507d2aacb7425085612e0d56131a57362729779bf3510c286b98568479314920::equipment::Equipment' '0x2::sui::SUI' \
--args \
'{EXCHANGE_OBJECT_ID}' \
'0x42ce68efec70dc482cafb4eb6f6e759074ab8397202cb8002f9fb33130951758' \
'"200000000"' \
'"11110"' \
'"100"' \
'0' \
'"500"' \
'"10"' \
'"100"' \
--gas-budget 100000000
```


#### Sell Movescription token to trade pool

Same as "Sell X token to buy pool". The function parameters:

* `_nft_service_config: &NftServiceConfig`.
* `pool: &mut TradePool<Movescription, Y>`: The ID of buy pool or trade pool object.
* `x: Movescription`: The ID of the `Movescription` object. Assume it's `0x221fe24766ee163ca1fcee68ffb894a189815f5d324cd7e5db2ea505dbb46b9b`.
* `y_coin: &mut Coin<Y>`: The SUI Coin object you own to accept the balance.
* `expected_y_amount_out: u64`: The minimum acceptable output amount is expected.

For example:

```shell
sui client call --package {DI_PACKAGE_ID} --module movescription_buy_pool_service --function sell_x \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'0x6367c30fc72767b43c0be0e3c50184a6b1302c03c8fa95c2236ee6477e55a3ef' \
'0x221fe24766ee163ca1fcee68ffb894a189815f5d324cd7e5db2ea505dbb46b9b' \
'0x4f2a2f3f3b564276d6ef103ade6f321d7a857b28236d8e0d6a628af416bb332a' \
'"100"' \
--gas-budget 100000000
```

#### Sell test NFT token to trade pool

Same as "Sell X token to buy pool". The function parameters:

* `_nft_service_config: &NftServiceConfig`.
* `pool: &mut TradePool<Equipment, Y>`: The ID of buy pool or trade pool object.
* `x: Equipment`: The ID of the `Equipment` object. Assume it's `0x221fe24766ee163ca1fcee68ffb894a189815f5d324cd7e5db2ea505dbb46b9b`.
* `y_coin: &mut Coin<Y>`: The SUI Coin object you own to accept the balance.
* `expected_y_amount_out: u64`: The minimum acceptable output amount is expected.

For example:

```shell
sui client call --package {DI_PACKAGE_ID} --module test_equipment_buy_pool_service --function sell_x \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'0xe564b59c43af59f002feb538851fe86fc85ad07fa2048320ad0c876f9ff9210a' \
'0x2b36b930f80ce73acc91456aa84021edf7de3d8ff27c4559305aef8d2b2b311c' \
'0x09d2790f76f11f12898e4049c2c72aaeaf32a0341797d797d038dae836457433' \
'"100"' \
--gas-budget 100000000
```

#### Buy Movescription token from trade pool

Same as "Buy X token from sell pool". The function parameters:

* `pool: &mut TradePool<X, Y>`: The ID of sell pool or trade pool object.
* `y_coin: Coin<Y>`: The SUI Coin object you own.
* `y_amount: u64`: The amount of SUI coin you would like to pay.
* `x_id: ID`: Assumes the ID of the NFT object you want to get is `0x221fe24766ee163ca1fcee68ffb894a189815f5d324cd7e5db2ea505dbb46b9b`.

So, execute the following command:

```shell
sui client call --package {CORE_PACKAGE_ID} --module sell_pool_service --function buy_x \
--type-args '0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff::movescription::Movescription' '0x2::sui::SUI' \
--args '0x6367c30fc72767b43c0be0e3c50184a6b1302c03c8fa95c2236ee6477e55a3ef' \
'0x4f2a2f3f3b564276d6ef103ade6f321d7a857b28236d8e0d6a628af416bb332a' \
'"120000"' \
'0x221fe24766ee163ca1fcee68ffb894a189815f5d324cd7e5db2ea505dbb46b9b' \
--gas-budget 100000000
```

#### Owner add X token to trade pool

Same as "Owner add X token to sell pool". No repetition here.

#### Deposit Y reserve to trade pool

Same as "Deposit Y reserve to buy pool".

#### Owner remove X token from trade pool

Same as "Owner remove X token from sell pool".

#### Owner withdraw Y reserve from trade pool

Same as "Owner withdraw Y reserve from sell pool".

### Token Pair tests

Unlike other Pools that use linear or exponential price curves, 
"Token Pair" in this repository uses the classic AMM constant product formula.

#### Initialize liquidity

Note the arguments required by the "initialize liquidity" function, which are assumed by the following test command:

* `_nft_service_config: &NftServiceConfig`: `{NFT_SERVICE_CONFIG_OBJECT_ID}`.
* `exchange: &mut Exchange`: Assuming the ID of the `Exchange` object is `{EXCHANGE_OBJECT_ID}`.
* `x: Movescription`: The ID of the `Movescription` object is `0x265d67ce5eea98b8a482c846537b0e0cb84b911d6b2d34cc78b3c81fc11d73d0`.
* `y_coin: Coin<Y>`: SUI coin object ID is `0x2d5aa8072b01f29fe074d4d0be89a33ebc4c4d63b6fc3bd0b611fde655a703e0`.
* `y_amount: u64`: `1000000`.
* `fee_numerator: u64`: `30`. We are going to set the pool fee rate to 0.3%.
* `fee_denominator: u64`: `10000`.

So, the command that needs to be executed is similar to the following:

```shell
sui client call --package {DI_PACKAGE_ID} --module movescription_token_pair_service --function initialize_liquidity \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'{EXCHANGE_OBJECT_ID}' \
'0x265d67ce5eea98b8a482c846537b0e0cb84b911d6b2d34cc78b3c81fc11d73d0' \
'0x2d5aa8072b01f29fe074d4d0be89a33ebc4c4d63b6fc3bd0b611fde655a703e0' \
'"1000000"' \
'"30"' \
'"10000"' \
--gas-budget 100000000
```

Note the ID of the output `TokenPair` object (we need to use it when adding liquidity):

```text
│  │ ObjectID: 0xb7355c68ca3a475549124774603de9626ecec27dad223cd177e7422be2c2933c
│  │ Sender: 0x...
│  │ Owner: Shared
│  │ ObjectType: 0x...::token_pair::TokenPair<...>
```

And note the ID of the output `LiquidityToken` object:

```text
│  ┌──
│  │ ObjectID: 0x22d93db8e5f477492b0c1ebfacaae89e3836dae62937ecd07215e5d52dd07e23
│  │ Sender: 0x...
│  │ Owner: Account Address ...
│  │ ObjectType: 0xf832b...::liquidity_token::LiquidityToken<...>
```

Use the following command to view the `Exchange` object,
and you can see the token pairs that have been created as well as the sell pools.

```shell
sui client object {EXCHANGE_OBJECT_ID}
```

#### Add liquidity

Add liquidity, the function parameters:

* `_nft_service_config: &NftServiceConfig`.
* `token_pair: &mut TokenPair<Movescription, Y>`.
* `liquidity_token: &mut LiquidityToken<Movescription, Y>`.
* `x: Movescription`: We assume another ID of the `Movescription` object is `0x265d67ce5eea98b8a482c846537b0e0cb84b911d6b2d34cc78b3c81fc11d73d0`.
* `y_coin: Coin<Y>`.
* `y_amount: u64`.

```shell
sui client call --package {DI_PACKAGE_ID} --module movescription_token_pair_service --function add_liquidity \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'0xb7355c68ca3a475549124774603de9626ecec27dad223cd177e7422be2c2933c' \
'0x22d93db8e5f477492b0c1ebfacaae89e3836dae62937ecd07215e5d52dd07e23' \
'0x265d67ce5eea98b8a482c846537b0e0cb84b911d6b2d34cc78b3c81fc11d73d0' \
'0x2d5aa8072b01f29fe074d4d0be89a33ebc4c4d63b6fc3bd0b611fde655a703e0' \
'"1000000"' \
--gas-budget 100000000
```

You can add liquidity multiple times.

#### Remove liquidity

Remove liquidity, the function parameters:

* `token_pair: &mut TokenPair<X, Y>`.
* `liquidity_token: &LiquidityToken<X, Y>`.
* `x_id: ID`: Assumes the ID of the NFT object you want to remove is `0x265d67ce5eea98b8a482c846537b0e0cb84b911d6b2d34cc78b3c81fc11d73d0`.
* `y_coin: &mut Coin<Y>`: The SUI Coin object used to accept the balance.

Execute the following command:

```shell
sui client call --package {CORE_PACKAGE_ID} --module token_pair_service --function remove_liquidity \
--type-args '0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff::movescription::Movescription' '0x2::sui::SUI' \
--args \
'0xb7355c68ca3a475549124774603de9626ecec27dad223cd177e7422be2c2933c' \
'0x22d93db8e5f477492b0c1ebfacaae89e3836dae62937ecd07215e5d52dd07e23' \
'0x265d67ce5eea98b8a482c846537b0e0cb84b911d6b2d34cc78b3c81fc11d73d0' \
'0x2d5aa8072b01f29fe074d4d0be89a33ebc4c4d63b6fc3bd0b611fde655a703e0' \
--gas-budget 100000000
```


#### Swap token X for token Y

Swap, to exchange Movescription token  (i.e. token X)  for token Y.

The function parameters:

* `_nft_service_config: &NftServiceConfig`.
* `token_pair: &mut TokenPair<Movescription, Y>`.
* `x: Movescription`: Assumes that the Movescription object ID is `0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9`.
* `y_coin: &mut Coin<Y>`: The SUI Coin object used to accept the balance.
* `expected_y_amount_out: u64`: The minimum acceptable output balance is expected.

Execute the following command:

```shell
sui client call --package {DI_PACKAGE_ID} --module movescription_token_pair_service --function swap_x \
--type-args '0x2::sui::SUI' \
--args \
'{NFT_SERVICE_CONFIG_OBJECT_ID}' \
'0xb7355c68ca3a475549124774603de9626ecec27dad223cd177e7422be2c2933c' \
'0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9' \
'0x2d5aa8072b01f29fe074d4d0be89a33ebc4c4d63b6fc3bd0b611fde655a703e0' \
'"100"' \
--gas-budget 100000000
```

#### Swap token Y for token X

In the opposite direction, token Y is exchanged for token X (NFT). The function parameters:

* `token_pair: &mut TokenPair<X, Y>`.
* `y_coin: Coin<Y>`: The SUI Coin object you own.
* `y_amount: u64`: The amount of SUI coin you would like to pay.
* `x_id: ID`: Assumes the ID of the NFT object you want to get is `0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9`.

So, execute the following command:

```shell
sui client call --package {CORE_PACKAGE_ID} --module token_pair_service --function swap_y \
--type-args '0xf4090a30c92074412c3004906c3c3e14a9d353ad84008ac2c23ae402ee80a6ff::movescription::Movescription' '0x2::sui::SUI' \
--args '0xb7355c68ca3a475549124774603de9626ecec27dad223cd177e7422be2c2933c' \
'0x2d5aa8072b01f29fe074d4d0be89a33ebc4c4d63b6fc3bd0b611fde655a703e0' \
'"1000000"' \
'0x28d7b12157b33cfaecfd5f62d971d80ccc0ad59ceb7265915104a124654cf6b9' \
--gas-budget 100000000
```

### Test off-chain service

#### Configuring off-chain service

Open the `application-test.yml` file located in the directory `sui-java-service/suiswapexample-service-rest/src/main/resources` and set the published transaction digest.

After setting, it should look like this:

```yaml
sui:
  contract:
    jsonrpc:
      url: "https://fullnode.testnet.sui.io/"
    package-publish-transaction: "{PUBLISH_CORE_PROJECT_TRANSACTION_DIGEST}"
```

This is the only place where off-chain service need to be configured, and it's that simple.


#### Creating a database for off-chain service

Use a MySQL client to connect to the local MySQL server and execute the following script to create an empty database (assuming the name is `test5`):

```sql
CREATE SCHEMA `test5` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_bin;
```

Go to the `sui-java-service` directory and package the Java project:

```shell
mvn package -DskipTests
```

Then, run a command-line tool to initialize the database:

```shell
java -jar ./suiswapexample-service-cli/target/suiswapexample-service-cli-0.0.1-SNAPSHOT.jar ddl -d "./scripts" -c "jdbc:mysql://127.0.0.1:3306/test5?enabledTLSProtocols=TLSv1.2&characterEncoding=utf8&serverTimezone=GMT%2b0&useLegacyDatetimeCode=false" -u root -p 123456
```

#### Starting off-chain service

In the `sui-java-service` directory, execute the following command to start the off-chain service:

```shell
mvn -pl suiswapexample-service-rest -am spring-boot:run
```

### About Off-Chain Service APIs

The off-chain service pulls the state of objects on chain into an off-chain SQL database to provide query functionality.
Such an off-chain service is sometimes called an indexer.

We can certainly start by using Sui's official API service, see: https://docs.sui.io/references/sui-api

However, there are some application-specific query requirements that Sui's official API service may not be able to fulfill, 
so it should be necessary to build your own or use enhanced query or indexer services provided by third parties.

By default, the off-chain service provide some out-of-the-box APIs - developers don't even need to write a single line of code for this.
You can read the DDDML model files and then refer to the examples below to infer what APIs are available.

For example, in our project, you can HTTP GET the list of token pairs from the URL like this:

```text
http://localhost:1023/api/TokenPairs
```

You can use query criteria:

```text
http://localhost:1023/api/TokenPairs?totalLiquidity=gt(100)&x_Reserve.tick=MOVE
```

Get the information of a token pair:

```text
http://localhost:1023/api/TokenPairs/0xe5bb0aa9fcd7ce57973bd3289f5b1ab0f946c47f3273641c3527a5d26775a5ac
```

Get a list of liquidity tokens:

```text
http://localhost:1023/api/LiquidityTokens
```

Get the information of a liquidity token:

```text
http://localhost:1023/api/LiquidityTokens/0x1c934038fbb356446add349062e9fad959820c5998c80f6f363969d07288cb16
```

#### Query parameters for getting entity lists

Query parameters that can be supported in the request URL for getting a list, including:

* `sort`: The name of the property to be used for sorting. Multiple names can be separated by commas. 
    A "-" in front of the name indicates reverse order. 
    The query parameter `sort` can appear multiple times, like this: `sort=fisrtName&sort=lastName,desc`.
* `fields`: The names of the fields (properties) to be returned. 
    Multiple names can be separated by commas.
* `filter`: The filter to return the result, explained further later (TBD).
* `firstResult`: The ordinal number of the first record returned in the result, starting from `0`.
* `maxResults`: The maximum number of records returned in the result.

#### Getting the entity list's page envelope

I personally don't like page "envelope", 
but because some developers requested it, 
we support sending a GET request to a URL to get a page envelope for the list:

```url
{BASE_URL}/{Entities}/_page?page={page}
```

Supported paging-related query parameters:

* `page`: Page number, starting from 0.
* `size`: Page size.

For example:

```text
http://localhost:1023/api/TokenPairs/_page?page=0&size=10
```

#### Need more query functionality?

Since the off-chain service already pulls the state of the objects on chain to the off-chain SQL database, 
we can query the off-chain service's database using any SQL query statement.
It is very easy to encapsulate these SQL query statements into an API. 
If you have such a need, modify the source code and add the API you need.


##  Further readings of dddappp

Flex Dapp powered by dddappp - the amazing Web3 low-code development platform.

Here is some readings of dddappp.

### Sui Crowdfunding Example

Another Sui Move sample project for teaching purposes. Repository: https://github.com/dddappp/sui-crowdfunding-example

You can refer to its README to refine the business logic of this project, as well as to test the application.

### Sui Blog Example

Repository: https://github.com/dddappp/sui-blog-example

It only requires 30 or so lines of code (all of which is a description of the domain model) to be written by the developer, and then generates a blog example that emulates [RoR Getting Started](https://guides.rubyonrails.org/getting_started.html) in one click, without requiring the developer to write a single line of other code.


### A More Complex Sui Demo

If you are interested, you can find a more complex Sui Demo here: ["A Sui Demo"](https://github.com/dddappp/A-Sui-Demo).


### Rooch Blog Example

Here is a Rooch version like above Sui blog example: https://github.com/rooch-network/rooch/blob/main/examples/blog/README.md

